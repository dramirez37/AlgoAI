{"prompt_id": "FA-E-0001", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm in Python that retrieves and logs the daily Price-to-Earnings (P/E) ratio for Apple (AAPL).\n\n**Core Logic Steps:**\n1. In `initialize`, add AAPL equity data with daily resolution and enable fundamental data.\n2. Schedule an event function (`log_pe_ratio`) to run daily, 30 minutes after market open for AAPL.\n3. In `log_pe_ratio`, get the AAPL `security` object.\n4. Check if the `security` object and its `fundamentals` property are available.\n5. Access the `valuation_ratios.pe_ratio` from the `fundamentals` data.\n6. Log the retrieved P/E ratio using a specific format. If the P/E ratio is unavailable (e.g., zero or None), log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"AAPL\", Resolution.Daily)` to request AAPL data.\n- Must enable fundamental data for the security (e.g., `security.set_fundamentals_required(True)` or via Universe settings).\n- Must use `self.schedule.on(self.date_rules.every_day(\"AAPL\"), self.time_rules.after_market_open(\"AAPL\", 30), self.log_pe_ratio)` for daily execution.\n- Must access the P/E ratio via `security.fundamentals.valuation_ratios.pe_ratio`.\n- Must use `self.log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only AAPL.\n- The logging action must be scheduled precisely 30 minutes after AAPL's market open each day.\n- Log output format for available P/E: \"AAPL P/E: [value]\"\n- Log output format for unavailable P/E: \"AAPL P/E: N/A\"\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_pe_ratio`).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include a check for data availability (`security` and `security.fundamentals` are not None) before accessing the P/E ratio.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging AAPL's daily P/E).\n* Key setup steps in `initialize` (adding equity, enabling fundamental data, scheduling).\n* How the `schedule.on` function is used to trigger the daily logging.\n* The specific API property used to access the P/E ratio (`fundamentals.valuation_ratios.pe_ratio`).\n* How the algorithm checks for data availability before attempting to access the P/E ratio.\n* How the algorithm handles cases where the P/E ratio might be unavailable (logging 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0002", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN Python algorithm to fetch and print the current Market Cap for Microsoft (MSFT) during initialization.\n\n**Core Logic Steps:**\n1. In `initialize`, add MSFT equity data with daily resolution.\n2. Enable fundamental data for MSFT (e.g., via Universe settings or `set_fundamentals_required`).\n3. Immediately after adding the equity, retrieve the MSFT `security` object.\n4. Check if the `security` object and its `fundamentals` property are available.\n5. Access the `market_cap` from the `fundamentals` data.\n6. Check if the Market Cap value is available and potentially valid (e.g., greater than zero).\n7. If available, print the Market Cap using `self.log`; otherwise, print 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"MSFT\", Resolution.Daily)` to request MSFT data.\n- Must enable fundamental data (e.g., `self.universe_settings.asynchronous = True` or `security.set_fundamentals_required(True)`).\n- Must access the Market Cap via `self.securities[\"MSFT\"].fundamentals.market_cap`.\n- Must use `self.log()` for output within the `initialize` method.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only MSFT.\n- The Market Cap fetching and printing must occur only once during the `initialize` phase, after the security and its fundamental data are likely available.\n- Print output format for available Market Cap: \"MSFT Initial Market Cap: [value]\"\n- Print output format for unavailable Market Cap: \"MSFT Initial Market Cap: N/A\"\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include a check immediately after `add_equity` to ensure the security object and its `fundamentals` exist before accessing `market_cap`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (printing MSFT's Market Cap at initialization).\n* Key setup steps in `initialize` (adding equity, enabling fundamental data).\n* Why the Market Cap retrieval happens within `initialize`.\n* The specific API property used to access the Market Cap (`fundamentals.market_cap`).\n* How the algorithm checks for the availability of the Security object and its fundamental data before accessing the Market Cap.\n* How the algorithm handles cases where the Market Cap might be unavailable (printing 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0003", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN Python script that plots the Trailing Twelve Months (TTM) Revenue for Amazon (AMZN) daily.\n\n**Core Logic Steps:**\n1. In `initialize`, add AMZN equity data with daily resolution and enable fundamental data.\n2. Create a `chart` named 'AMZN Fundamentals' and register a `series` named 'Revenue TTM' associated with that chart.\n3. Schedule an event function (`plot_revenue`) to run daily, at market close for AMZN.\n4. In `plot_revenue`, get the AMZN `security` object.\n5. Check if the `security` object and its `fundamentals` property are available.\n6. Access the TTM Revenue (`financial_statements.income_statement.total_revenue.twelve_months`) from the `fundamentals` data.\n7. Check if the retrieved revenue value is valid (not None).\n8. If valid, plot the revenue value using the 'Revenue TTM' series on the 'AMZN Fundamentals' chart.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"AMZN\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.set_fundamentals_required(True)`).\n- Must use `Chart('AMZN Fundamentals')` and `Series('Revenue TTM', series_type.line, 0)` for plot setup in `initialize`.\n- Must use `self.plot('AMZN Fundamentals', 'Revenue TTM', value)` to plot the data.\n- Must use `self.schedule.on(self.date_rules.every_day(\"AMZN\"), self.time_rules.at_market_close(\"AMZN\"), self.plot_revenue)` for daily execution.\n- Must access the TTM Revenue via `security.fundamentals.financial_statements.income_statement.total_revenue.twelve_months`.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only AMZN.\n- Plotting must occur exactly once per trading day, at market close.\n- The plot must be named 'AMZN Fundamentals'.\n- The series must be named 'Revenue TTM'.\n- Only plot valid revenue figures (must check if the value is available and not None).\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals, plot creation, scheduling).\n- Implement the scheduled event handler method (`plot_revenue`).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.fundamentals`, and the specific revenue value) before attempting to plot.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (plotting AMZN's TTM Revenue daily).\n* Key setup steps in `initialize` (adding equity, fundamental data, creating the chart and series, scheduling).\n* How the `schedule.on` function is used to trigger the daily plotting at market close.\n* The specific API property used to access the TTM Revenue.\n* How the `plot` function is used with the specified chart and series names.\n* How the algorithm checks for data availability before attempting to access and plot the revenue.\n* Any assumptions made (e.g., assuming TTM Revenue data is consistently available)."}
{"prompt_id": "FA-E-0004", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a LEAN Python algorithm that accesses and logs the Debt-to-Equity ratio for Tesla (TSLA) every trading day.\n\n**Core Logic Steps:**\n1. In `initialize`, add TSLA equity data with daily resolution and enable fundamental data.\n2. Schedule an event function (`log_debt_equity_ratio`) to run daily, 15 minutes before market close for TSLA.\n3. In `log_debt_equity_ratio`, get the TSLA `security` object.\n4. Check if the `security` object and its `fundamentals` property are available.\n5. Access the Debt-to-Equity ratio (`operation_ratios.debt_equity_ratio.one_year`) from the `fundamentals` data.\n6. Check if the retrieved ratio value is valid (not None).\n7. If valid, log the ratio using `self.log`; otherwise, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"TSLA\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.set_fundamentals_required(True)`).\n- Must use `self.schedule.on(self.date_rules.every_day(\"TSLA\"), self.time_rules.before_market_close(\"TSLA\", 15), self.log_debt_equity_ratio)`.\n- Must access the ratio via `security.fundamentals.operation_ratios.debt_equity_ratio.one_year`.\n- Must use `self.log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only TSLA.\n- Logging must occur exactly once per trading day, 15 minutes before TSLA's market close.\n- Log output format for available ratio: \"TSLA Debt/Equity Ratio: [value]\"\n- Log output format for unavailable ratio: \"TSLA Debt/Equity Ratio: N/A\"\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_debt_equity_ratio`).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.fundamentals`) before accessing the ratio.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging TSLA's daily Debt-to-Equity ratio).\n* Key setup steps in `initialize` (adding equity, fundamental data, scheduling).\n* How `schedule.on` triggers the daily logging before market close.\n* The specific API property used to access the Debt-to-Equity ratio (`operation_ratios.debt_equity_ratio.one_year`).\n* How the algorithm checks for data availability before accessing the ratio.\n* How the algorithm handles cases where the ratio might be unavailable (logging 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0005", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that gets and stores the latest Dividend Yield for Johnson & Johnson (JNJ) in a variable daily.\n\n**Core Logic Steps:**\n1. In `initialize`, add JNJ equity data with daily resolution and enable fundamental data.\n2. Declare a class member variable `self.latest_dividend_yield` initialized to `None`.\n3. Schedule an event function (`update_dividend_yield`) to run daily, at market open for JNJ.\n4. In `update_dividend_yield`, get the JNJ `security` object.\n5. Check if the `security` object and its `fundamentals` property are available.\n6. Access the Dividend Yield (`valuation_ratios.dividend_yield`) from the `fundamentals` data.\n7. Check if the retrieved yield value is valid (not None).\n8. If valid, update `self.latest_dividend_yield` with the new value and log the update.\n9. If not valid, log that no update occurred.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"JNJ\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.set_fundamentals_required(True)`).\n- Must use `self.schedule.on(self.date_rules.every_day(\"JNJ\"), self.time_rules.at_market_open(\"JNJ\"), self.update_dividend_yield)`.\n- Must access the yield via `security.fundamentals.valuation_ratios.dividend_yield`.\n- Must store the value in a class member variable named exactly `self.latest_dividend_yield`.\n- Must use `self.log()` to confirm the update or unavailability.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only JNJ.\n- The update check must occur exactly once per trading day, precisely at JNJ's market open.\n- The dividend yield must be stored in a class variable named `latest_dividend_yield`.\n- Log message on successful update: \"JNJ Dividend Yield updated to: [value]\"\n- Log message if yield is unavailable: \"JNJ Dividend Yield not available today.\"\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals, variable initialization, scheduling).\n- Implement the scheduled event handler method (`update_dividend_yield`).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.fundamentals`, and the yield value itself) before updating the variable.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (storing JNJ's latest Dividend Yield daily).\n* Key setup steps in `initialize` (adding equity, fundamental data, initializing the variable `self.latest_dividend_yield`, scheduling).\n* How `schedule.on` triggers the daily update at market open.\n* The specific API property used to access the Dividend Yield (`valuation_ratios.dividend_yield`).\n* How the retrieved value is stored in the required class variable `self.latest_dividend_yield`.\n* How the algorithm checks for data availability before accessing the yield.\n* How the algorithm handles cases where the yield might be unavailable and the corresponding log message.\n* The format of the log messages for both successful updates and unavailable data."}
{"prompt_id": "FA-E-0006", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN Python script to log the Price-to-Book (P/B) ratio for Google (GOOG) each day.\n\n**Core Logic Steps:**\n1. In `initialize`, add GOOG equity data with daily resolution and enable fundamental data.\n2. Schedule an event function (`log_pb_ratio`) to run daily, 45 minutes after market open for GOOG.\n3. In `log_pb_ratio`, get the GOOG `security` object.\n4. Check if the `security` object and its `fundamentals` property are available.\n5. Access the `valuation_ratios.pb_ratio` from the `fundamentals` data.\n6. Log the retrieved P/B ratio using a specific format. If the P/B ratio is unavailable (e.g., zero or None), log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"GOOG\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.set_fundamentals_required(True)`).\n- Must use `self.schedule.on(self.date_rules.every_day(\"GOOG\"), self.time_rules.after_market_open(\"GOOG\", 45), self.log_pb_ratio)`.\n- Must access the P/B ratio via `security.fundamentals.valuation_ratios.pb_ratio`.\n- Must use `self.log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only GOOG.\n- The logging action must be scheduled precisely 45 minutes after GOOG's market open each day.\n- Log output format for available P/B: \"GOOG P/B Ratio: [value]\"\n- Log output format for unavailable P/B: \"GOOG P/B Ratio: N/A\"\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_pb_ratio`).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks for data availability (`security` and `security.fundamentals`) before accessing the P/B ratio.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging GOOG's daily P/B ratio).\n* Key setup steps in `initialize` (adding equity, enabling fundamental data, scheduling).\n* How the `schedule.on` function is used to trigger the daily logging.\n* The specific API property used to access the P/B ratio (`fundamentals.valuation_ratios.pb_ratio`).\n* How the algorithm checks for data availability before attempting to access the P/B ratio.\n* How the algorithm handles cases where the P/B ratio might be unavailable (logging 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0007", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm that fetches and plots the annual Net Income for NVIDIA (NVDA) when fundamental data is updated.\n\n**Core Logic Steps:**\n1. In `initialize`, add NVDA equity data with daily resolution and enable fundamental data.\n2. Define a universe selection function (even if only for NVDA) or use `set_fundamentals_required(True)` for the NVDA security.\n3. Implement the `on_fundamentals` method which receives `fine_fundamental` data.\n4. Create a `chart` named 'NVDA Annual Data' and register a `series` named 'Net Income' in `initialize`.\n5. Inside `on_fundamentals`, filter for the NVDA symbol (`fine.symbol == self.nvda_symbol`).\n6. Access the annual Net Income (`financial_statements.income_statement.net_income.one_year`) from the `fine` object.\n7. Check if the retrieved Net Income value is valid (not None).\n8. If valid, plot the value using the 'Net Income' series on the 'NVDA Annual Data' chart.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"NVDA\", Resolution.Daily)`.\n- Must enable fundamental data reception, either via `security.set_fundamentals_required(True)` or by implementing a Universe selection function using `self.add_universe(self.fundamental_function)`.\n- Must implement the `on_fundamentals(self, fine)` method if using universe selection, or handle fundamental data within `on_data` if using `set_fundamentals_required`.\n- Must use `Chart('NVDA Annual Data')` and `Series('Net Income', series_type.line, 0)` for plot setup in `initialize`.\n- Must access the annual Net Income via `fine.financial_statements.income_statement.net_income.one_year` (within `on_fundamentals`) or `security.fundamentals.financial_statements.income_statement.net_income.one_year` (within `on_data` or scheduled event).\n- Must use `self.plot('NVDA Annual Data', 'Net Income', value)`.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only NVDA's fundamental updates.\n- Plotting must occur *only* when new fundamental data for NVDA is processed (typically via `on_fundamentals` or checking for updates in `on_data`).\n- The plot must be named 'NVDA Annual Data'.\n- The series must be named 'Net Income'.\n- Only plot valid Net Income figures (check for availability/None).\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals, plot creation).\n- Implement the method handling fundamental data updates (`on_fundamentals` or equivalent logic in `on_data`).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks for data availability (e.g., `fine` object properties or `security.fundamentals`) before plotting.\n- Store the NVDA `symbol` object in `initialize` for comparison if using `on_fundamentals`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (plotting NVDA's annual Net Income upon fundamental updates).\n* Key setup steps in `initialize` (adding equity, enabling fundamentals, creating chart/series).\n* How fundamental data updates are captured (either `on_fundamentals` or checking `security.fundamentals` staleness).\n* The specific API property used to access the *annual* Net Income.\n* How the `plot` function is used with the specified chart and series names.\n* How the algorithm ensures it only plots data for NVDA.\n* How the algorithm checks for data validity before plotting."}
{"prompt_id": "FA-E-0008", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python algorithm to print the Sector Name for SPY ETF during the `initialize` method.\n\n**Core Logic Steps:**\n1. In `initialize`, add SPY ETF data with daily resolution.\n2. Enable fundamental data access (required for asset classification).\n3. Immediately after adding the ETF, retrieve the SPY `security` object.\n4. Check if the `security` object and its `fundamentals` property are available.\n5. Access the Sector Name (`asset_classification.morningstar_sector_code`) from the `fundamentals` data. Note: Sector Name might not be directly available; `morningstar_sector_code` is the typical field.\n6. Check if the Sector Code value is available (not None or empty).\n7. If available, print the Sector Code using `self.log`; otherwise, print 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"SPY\", Resolution.Daily)` (or `add_etf`).\n- Must enable fundamental data (e.g., `self.universe_settings.asynchronous = True`).\n- Must access the Sector Code via `self.securities[\"SPY\"].fundamentals.asset_classification.morningstar_sector_code`.\n- Must use `self.log()` for output within the `initialize` method.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only SPY.\n- The Sector Code fetching and printing must occur only once during the `initialize` phase, after the security and its fundamental data are likely available.\n- Print output format for available Sector Code: \"SPY Sector Code: [value]\"\n- Print output format for unavailable Sector Code: \"SPY Sector Code: N/A\"\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include a check immediately after `add_equity` to ensure the security object and its `fundamentals` exist before accessing `asset_classification`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (printing SPY's Sector Code at initialization).\n* Key setup steps in `initialize` (adding ETF, enabling fundamental data).\n* Why the Sector Code retrieval happens within `initialize`.\n* The specific API property used to access the Sector Code (`fundamentals.asset_classification.morningstar_sector_code`).\n* How the algorithm checks for the availability of the Security object and its fundamental data before accessing the Sector Code.\n* How the algorithm handles cases where the Sector Code might be unavailable (printing 'N/A').\n* The format of the log output.\n* A note that ETFs might use different classification fields than stocks."}
{"prompt_id": "FA-E-0009", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect script that retrieves and logs the Return on Equity (ROE) for Meta Platforms (META) daily.\n\n**Core Logic Steps:**\n1. In `initialize`, add META equity data with daily resolution and enable fundamental data.\n2. Schedule an event function (`log_roe`) to run daily, one hour after market open for META.\n3. In `log_roe`, get the META `security` object.\n4. Check if the `security` object and its `fundamentals` property are available.\n5. Access the TTM Return on Equity (`operation_ratios.roe.one_year`) from the `fundamentals` data.\n6. Check if the retrieved ROE value is valid (not None).\n7. If valid, log the ROE using `self.log`; otherwise, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"META\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.set_fundamentals_required(True)`).\n- Must use `self.schedule.on(self.date_rules.every_day(\"META\"), self.time_rules.after_market_open(\"META\", 60), self.log_roe)`.\n- Must access the ROE via `security.fundamentals.operation_ratios.roe.one_year` (TTM/Annual ROE).\n- Must use `self.log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only META.\n- Logging must occur exactly once per trading day, 60 minutes after META's market open.\n- Log output format for available ROE: \"META ROE (TTM): [value]\"\n- Log output format for unavailable ROE: \"META ROE (TTM): N/A\"\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_roe`).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.fundamentals`) before accessing the ROE.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging META's daily TTM ROE).\n* Key setup steps in `initialize` (adding equity, enabling fundamental data, scheduling).\n* How `schedule.on` triggers the daily logging after market open.\n* The specific API property used to access the TTM Return on Equity (`operation_ratios.roe.one_year`).\n* How the algorithm checks for data availability before accessing the ROE.\n* How the algorithm handles cases where the ROE might be unavailable (logging 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0010", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that plots the Quick Ratio for Berkshire Hathaway (BRK.B) every trading day.\n\n**Core Logic Steps:**\n1. In `initialize`, add BRK.B equity data with daily resolution and enable fundamental data.\n2. Create a `chart` named 'BRK.B Ratios' and register a `series` named 'Quick Ratio' associated with that chart.\n3. Schedule an event function (`plot_quick_ratio`) to run daily, 30 minutes before market close for BRK.B.\n4. In `plot_quick_ratio`, get the BRK.B `security` object.\n5. Check if the `security` object and its `fundamentals` property are available.\n6. Access the Quick Ratio (`operation_ratios.quick_ratio.one_year`) from the `fundamentals` data.\n7. Check if the retrieved ratio value is valid (not None).\n8. If valid, plot the ratio value using the 'Quick Ratio' series on the 'BRK.B Ratios' chart.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"BRK.B\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.set_fundamentals_required(True)`).\n- Must use `Chart('BRK.B Ratios')` and `Series('Quick Ratio', series_type.line, 0)` for plot setup in `initialize`.\n- Must use `self.plot('BRK.B Ratios', 'Quick Ratio', value)` to plot the data.\n- Must use `self.schedule.on(self.date_rules.every_day(\"BRK.B\"), self.time_rules.before_market_close(\"BRK.B\", 30), self.plot_quick_ratio)`.\n- Must access the Quick Ratio via `security.fundamentals.operation_ratios.quick_ratio.one_year` (or another period like `.three_months` if specified).\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only BRK.B.\n- Plotting must occur exactly once per trading day, 30 minutes before market close.\n- The plot must be named 'BRK.B Ratios'.\n- The series must be named 'Quick Ratio'.\n- Only plot valid ratio figures (must check if the value is available and not None).\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals, plot creation, scheduling).\n- Implement the scheduled event handler method (`plot_quick_ratio`).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.fundamentals`, and the specific ratio value) before attempting to plot.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (plotting BRK.B's Quick Ratio daily).\n* Key setup steps in `initialize` (adding equity, fundamental data, creating chart/series, scheduling).\n* How `schedule.on` triggers the daily plotting before market close.\n* The specific API property used to access the Quick Ratio (specify the period, e.g., `one_year`).\n* How the `plot` function is used with the specified chart and series names.\n* How the algorithm checks for data availability before attempting to access and plot the ratio.\n* Any assumptions made."}
{"prompt_id": "FA-E-0011", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and log the Earnings Per Share (EPS) TTM for Visa (V) daily.\n\n**Core Logic Steps:**\n1. In `initialize`, add V equity data with daily resolution and enable fundamental data.\n2. Schedule an event function (`log_eps_ttm`) to run daily, at market open for V.\n3. In `log_eps_ttm`, get the V `security` object.\n4. Check if the `security` object and its `fundamentals` property are available.\n5. Access the TTM EPS (`earning_ratios.eps_ttm`) from the `fundamentals` data.\n6. Check if the retrieved EPS value is valid (not None).\n7. If valid, log the EPS using `self.log`; otherwise, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"V\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.set_fundamentals_required(True)`).\n- Must use `self.schedule.on(self.date_rules.every_day(\"V\"), self.time_rules.at_market_open(\"V\"), self.log_eps_ttm)`.\n- Must access the TTM EPS via `security.fundamentals.earning_ratios.eps_ttm`.\n- Must use `self.log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only V.\n- Logging must occur exactly once per trading day, at V's market open.\n- Log output format for available EPS: \"V EPS TTM: [value]\"\n- Log output format for unavailable EPS: \"V EPS TTM: N/A\"\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_eps_ttm`).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.fundamentals`) before accessing the EPS.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging V's daily TTM EPS).\n* Key setup steps in `initialize` (adding equity, fundamental data, scheduling).\n* How `schedule.on` triggers the daily logging at market open.\n* The specific API property used to access the TTM Earnings Per Share (`earning_ratios.eps_ttm`).\n* How the algorithm checks for data availability before accessing the EPS.\n* How the algorithm handles cases where the EPS might be unavailable (logging 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0012", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the current Total Assets for JPMorgan Chase (JPM) during initialization.\n\n**Core Logic Steps:**\n1. In `initialize`, add JPM equity data with daily resolution.\n2. Enable fundamental data for JPM.\n3. Immediately after adding the equity, retrieve the JPM `security` object.\n4. Check if the `security` object and its `fundamentals` property, specifically `financial_statements`, are available.\n5. Access the latest Total Assets (`financial_statements.balance_sheet.total_assets.value`) from the `fundamentals` data. Note: This gives the value from the latest reported balance sheet.\n6. Check if the Total Assets value is available and potentially valid (e.g., greater than zero).\n7. If available, print the Total Assets using `self.log`; otherwise, print 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"JPM\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `self.universe_settings.asynchronous = True` or `security.set_fundamentals_required(True)`).\n- Must access Total Assets via `self.securities[\"JPM\"].fundamentals.financial_statements.balance_sheet.total_assets.value`.\n- Must use `self.log()` for output within the `initialize` method.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only JPM.\n- The Total Assets fetching and printing must occur only once during the `initialize` phase, after the security and its fundamental data are likely available.\n- Print output format for available Total Assets: \"JPM Initial Total Assets: [value]\"\n- Print output format for unavailable Total Assets: \"JPM Initial Total Assets: N/A\"\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks immediately after `add_equity` to ensure the security object, `fundamentals`, `financial_statements`, and `balance_sheet` exist before accessing `total_assets`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (printing JPM's latest reported Total Assets at initialization).\n* Key setup steps in `initialize` (adding equity, enabling fundamental data).\n* Why the Total Assets retrieval happens within `initialize`.\n* The specific API property used to access the latest Total Assets (`financial_statements.balance_sheet.total_assets.value`).\n* How the algorithm performs nested checks for data availability (Security, Fundamentals, FinancialStatements, BalanceSheet) before accessing the value.\n* How the algorithm handles cases where Total Assets might be unavailable (printing 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0013", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that plots the Operating Margin TTM for Walmart (WMT) daily.\n\n**Core Logic Steps:**\n1. In `initialize`, add WMT equity data with daily resolution and enable fundamental data.\n2. Create a `chart` named 'WMT Margins' and register a `series` named 'Operating Margin TTM' associated with that chart.\n3. Schedule an event function (`plot_op_margin`) to run daily, at market close for WMT.\n4. In `plot_op_margin`, get the WMT `security` object.\n5. Check if the `security` object and its `fundamentals` property are available.\n6. Access the TTM Operating Margin (`operation_ratios.operating_margin.one_year`) from the `fundamentals` data.\n7. Check if the retrieved margin value is valid (not None).\n8. If valid, plot the margin value using the 'Operating Margin TTM' series on the 'WMT Margins' chart.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"WMT\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.set_fundamentals_required(True)`).\n- Must use `Chart('WMT Margins')` and `Series('Operating Margin TTM', series_type.line, 0)` for plot setup in `initialize`.\n- Must use `self.plot('WMT Margins', 'Operating Margin TTM', value)` to plot the data.\n- Must use `self.schedule.on(self.date_rules.every_day(\"WMT\"), self.time_rules.at_market_close(\"WMT\"), self.plot_op_margin)`.\n- Must access the TTM Operating Margin via `security.fundamentals.operation_ratios.operating_margin.one_year`.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only WMT.\n- Plotting must occur exactly once per trading day, at market close.\n- The plot must be named 'WMT Margins'.\n- The series must be named 'Operating Margin TTM'.\n- Only plot valid margin figures (must check if the value is available and not None).\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals, plot creation, scheduling).\n- Implement the scheduled event handler method (`plot_op_margin`).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.fundamentals`, and the specific margin value) before attempting to plot.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (plotting WMT's TTM Operating Margin daily).\n* Key setup steps in `initialize` (adding equity, fundamental data, creating chart/series, scheduling).\n* How `schedule.on` triggers the daily plotting at market close.\n* The specific API property used to access the TTM Operating Margin (`operation_ratios.operating_margin.one_year`).\n* How the `plot` function is used with the specified chart and series names.\n* How the algorithm checks for data availability before attempting to access and plot the margin.\n* Any assumptions made."}
{"prompt_id": "FA-E-0014", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that retrieves and logs the Price-to-Sales (P/S) ratio for Procter & Gamble (PG) daily.\n\n**Core Logic Steps:**\n1. In `initialize`, add PG equity data with daily resolution and enable fundamental data.\n2. Schedule an event function (`log_ps_ratio`) to run daily, 20 minutes after market open for PG.\n3. In `log_ps_ratio`, get the PG `security` object.\n4. Check if the `security` object and its `fundamentals` property are available.\n5. Access the `valuation_ratios.ps_ratio` from the `fundamentals` data.\n6. Log the retrieved P/S ratio using a specific format. If the P/S ratio is unavailable (e.g., zero or None), log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"PG\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.set_fundamentals_required(True)`).\n- Must use `self.schedule.on(self.date_rules.every_day(\"PG\"), self.time_rules.after_market_open(\"PG\", 20), self.log_ps_ratio)`.\n- Must access the P/S ratio via `security.fundamentals.valuation_ratios.ps_ratio`.\n- Must use `self.log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only PG.\n- The logging action must be scheduled precisely 20 minutes after PG's market open each day.\n- Log output format for available P/S: \"PG P/S Ratio: [value]\"\n- Log output format for unavailable P/S: \"PG P/S Ratio: N/A\"\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_ps_ratio`).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks for data availability (`security` and `security.fundamentals`) before accessing the P/S ratio.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging PG's daily P/S ratio).\n* Key setup steps in `initialize` (adding equity, enabling fundamental data, scheduling).\n* How the `schedule.on` function is used to trigger the daily logging.\n* The specific API property used to access the P/S ratio (`fundamentals.valuation_ratios.ps_ratio`).\n* How the algorithm checks for data availability before attempting to access the P/S ratio.\n* How the algorithm handles cases where the P/S ratio might be unavailable (logging 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0015", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and print the Industry Name for UnitedHealth Group (UNH) in the `initialize` function.\n\n**Core Logic Steps:**\n1. In `initialize`, add UNH equity data with daily resolution.\n2. Enable fundamental data for UNH.\n3. Immediately after adding the equity, retrieve the UNH `security` object.\n4. Check if the `security` object and its `fundamentals` property, specifically `asset_classification`, are available.\n5. Access the Industry Group Name (`asset_classification.morningstar_industry_group_name`) from the `fundamentals` data.\n6. Check if the Industry Group Name value is available (not None or empty).\n7. If available, print the Industry Group Name using `self.log`; otherwise, print 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"UNH\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `self.universe_settings.asynchronous = True` or `security.set_fundamentals_required(True)`).\n- Must access the Industry Group Name via `self.securities[\"UNH\"].fundamentals.asset_classification.morningstar_industry_group_name`.\n- Must use `self.log()` for output within the `initialize` method.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only UNH.\n- The Industry Group Name fetching and printing must occur only once during the `initialize` phase, after the security and its fundamental data are likely available.\n- Print output format for available name: \"UNH Industry Group Name: [value]\"\n- Print output format for unavailable name: \"UNH Industry Group Name: N/A\"\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks immediately after `add_equity` to ensure the security object, `fundamentals`, and `asset_classification` exist before accessing `morningstar_industry_group_name`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (printing UNH's Industry Group Name at initialization).\n* Key setup steps in `initialize` (adding equity, enabling fundamental data).\n* Why the Industry Group Name retrieval happens within `initialize`.\n* The specific API property used to access the Industry Group Name (`fundamentals.asset_classification.morningstar_industry_group_name`).\n* How the algorithm performs nested checks for data availability (Security, Fundamentals, AssetClassification) before accessing the value.\n* How the algorithm handles cases where the name might be unavailable (printing 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0016", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to log the annual Free Cash Flow for AAPL when fundamental data becomes available.\n\n**Core Logic Steps:**\n1. In `initialize`, add AAPL equity data with daily resolution and enable fundamental data.\n2. Implement the `on_fundamentals` method (or equivalent logic in `on_data` by checking `security.fundamentals` updates).\n3. Store the AAPL symbol object in `initialize` for comparison (e.g., `self.aapl_symbol`).\n4. Inside the fundamental data handler (`on_fundamentals` or `on_data` block), filter for the AAPL symbol.\n5. Access the annual Free Cash Flow (`financial_statements.cash_flow_statement.free_cash_flow.one_year`) from the fundamental data object (`fine` or `security.fundamentals`).\n6. Check if the retrieved Free Cash Flow value is valid (not None).\n7. If valid, log the value using `self.log` with a specific format.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"AAPL\", Resolution.Daily)`.\n- Must enable fundamental data reception (e.g., `security.set_fundamentals_required(True)` or `add_universe`).\n- Must handle fundamental data, preferably via `on_fundamentals(self, fine)` or by checking `security.fundamentals` updates in `on_data`.\n- Must access the annual Free Cash Flow via `.financial_statements.cash_flow_statement.free_cash_flow.one_year`.\n- Must use `self.log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only AAPL's fundamental updates.\n- Logging must occur *only* when new fundamental data containing the annual Free Cash Flow for AAPL is processed.\n- Log output format: \"AAPL Annual Free Cash Flow (Updated [Date]): [value]\"\n- Only log valid Free Cash Flow figures (check for availability/None).\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals).\n- Implement the method handling fundamental data updates (`on_fundamentals` or equivalent `on_data` logic).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks for data availability (`fine` object or `security.fundamentals`, relevant nested properties) before logging.\n- Store the AAPL `symbol` object in `initialize` for comparison.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging AAPL's annual Free Cash Flow upon fundamental updates).\n* Key setup steps in `initialize` (adding equity, enabling fundamentals, storing symbol).\n* How fundamental data updates are captured and filtered for AAPL.\n* The specific API property used to access the *annual* Free Cash Flow.\n* How the `log` function is used with the specified format.\n* How the algorithm checks for data validity before logging.\n* The timing of when the logging occurs (upon fundamental update arrival)."}
{"prompt_id": "FA-E-0017", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that plots the Current Ratio for MSFT daily.\n\n**Core Logic Steps:**\n1. In `initialize`, add MSFT equity data with daily resolution and enable fundamental data.\n2. Create a `chart` named 'MSFT Ratios' and register a `series` named 'Current Ratio' associated with that chart.\n3. Schedule an event function (`plot_current_ratio`) to run daily, 10 minutes after market open for MSFT.\n4. In `plot_current_ratio`, get the MSFT `security` object.\n5. Check if the `security` object and its `fundamentals` property are available.\n6. Access the Current Ratio (`operation_ratios.current_ratio.one_year`) from the `fundamentals` data.\n7. Check if the retrieved ratio value is valid (not None).\n8. If valid, plot the ratio value using the 'Current Ratio' series on the 'MSFT Ratios' chart.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"MSFT\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.set_fundamentals_required(True)`).\n- Must use `Chart('MSFT Ratios')` and `Series('Current Ratio', series_type.line, 0)` for plot setup in `initialize`.\n- Must use `self.plot('MSFT Ratios', 'Current Ratio', value)` to plot the data.\n- Must use `self.schedule.on(self.date_rules.every_day(\"MSFT\"), self.time_rules.after_market_open(\"MSFT\", 10), self.plot_current_ratio)`.\n- Must access the Current Ratio via `security.fundamentals.operation_ratios.current_ratio.one_year` (or specify another period like `.three_months`).\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only MSFT.\n- Plotting must occur exactly once per trading day, 10 minutes after market open.\n- The plot must be named 'MSFT Ratios'.\n- The series must be named 'Current Ratio'.\n- Only plot valid ratio figures (must check if the value is available and not None).\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals, plot creation, scheduling).\n- Implement the scheduled event handler method (`plot_current_ratio`).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.fundamentals`, and the specific ratio value) before attempting to plot.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (plotting MSFT's Current Ratio daily).\n* Key setup steps in `initialize` (adding equity, fundamental data, creating chart/series, scheduling).\n* How `schedule.on` triggers the daily plotting after market open.\n* The specific API property used to access the Current Ratio (specify the period, e.g., `one_year`).\n* How the `plot` function is used with the specified chart and series names.\n* How the algorithm checks for data availability before attempting to access and plot the ratio.\n* Any assumptions made."}
{"prompt_id": "FA-E-0018", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that retrieves and logs the Book Value Per Share for GOOG every trading day.\n\n**Core Logic Steps:**\n1. In `initialize`, add GOOG equity data with daily resolution and enable fundamental data.\n2. Schedule an event function (`log_bvps`) to run daily, 5 minutes before market close for GOOG.\n3. In `log_bvps`, get the GOOG `security` object.\n4. Check if the `security` object and its `fundamentals` property are available.\n5. Access the Book Value Per Share (`valuation_ratios.book_value_per_share`) from the `fundamentals` data.\n6. Check if the retrieved BVPS value is valid (not None).\n7. If valid, log the BVPS using `self.log`; otherwise, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"GOOG\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.set_fundamentals_required(True)`).\n- Must use `self.schedule.on(self.date_rules.every_day(\"GOOG\"), self.time_rules.before_market_close(\"GOOG\", 5), self.log_bvps)`.\n- Must access the BVPS via `security.fundamentals.valuation_ratios.book_value_per_share`.\n- Must use `self.log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only GOOG.\n- Logging must occur exactly once per trading day, 5 minutes before GOOG's market close.\n- Log output format for available BVPS: \"GOOG Book Value Per Share: [value]\"\n- Log output format for unavailable BVPS: \"GOOG Book Value Per Share: N/A\"\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_bvps`).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.fundamentals`) before accessing the BVPS.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging GOOG's daily Book Value Per Share).\n* Key setup steps in `initialize` (adding equity, fundamental data, scheduling).\n* How `schedule.on` triggers the daily logging before market close.\n* The specific API property used to access the Book Value Per Share (`valuation_ratios.book_value_per_share`).\n* How the algorithm checks for data availability before accessing the BVPS.\n* How the algorithm handles cases where the BVPS might be unavailable (logging 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0019", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and store the Beta value for AMZN in a variable daily.\n\n**Core Logic Steps:**\n1. In `initialize`, add AMZN equity data with daily resolution and enable fundamental data.\n2. Declare a class member variable `self.latest_beta` initialized to `None`.\n3. Schedule an event function (`update_beta`) to run daily, at market open for AMZN.\n4. In `update_beta`, get the AMZN `security` object.\n5. Check if the `security` object and its `fundamentals` property are available.\n6. Access the Beta (`operation_ratios.beta.one_year`) from the `fundamentals` data.\n7. Check if the retrieved Beta value is valid (not None).\n8. If valid, update `self.latest_beta` with the new value and log the update.\n9. If not valid, log that no update occurred.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"AMZN\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.set_fundamentals_required(True)`).\n- Must use `self.schedule.on(self.date_rules.every_day(\"AMZN\"), self.time_rules.at_market_open(\"AMZN\"), self.update_beta)`.\n- Must access the Beta via `security.fundamentals.operation_ratios.beta.one_year` (specify period if different, e.g., `three_months`).\n- Must store the value in a class member variable named exactly `self.latest_beta`.\n- Must use `self.log()` to confirm the update or unavailability.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only AMZN.\n- The update check must occur exactly once per trading day, precisely at AMZN's market open.\n- The Beta value must be stored in a class variable named `latest_beta`.\n- Log message on successful update: \"AMZN Beta updated to: [value]\"\n- Log message if Beta is unavailable: \"AMZN Beta not available today.\"\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals, variable initialization, scheduling).\n- Implement the scheduled event handler method (`update_beta`).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.fundamentals`, and the Beta value itself) before updating the variable.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (storing AMZN's latest Beta value daily).\n* Key setup steps in `initialize` (adding equity, fundamental data, initializing the variable `self.latest_beta`, scheduling).\n* How `schedule.on` triggers the daily update at market open.\n* The specific API property used to access the Beta (mentioning the `one_year` period).\n* How the retrieved value is stored in the required class variable `self.latest_beta`.\n* How the algorithm checks for data availability before accessing the Beta.\n* How the algorithm handles cases where the Beta might be unavailable and the corresponding log message.\n* The format of the log messages."}
{"prompt_id": "FA-E-0020", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the latest Trailing Twelve Months Operating Cash Flow for TSLA during initialization.\n\n**Core Logic Steps:**\n1. In `initialize`, add TSLA equity data with daily resolution.\n2. Enable fundamental data for TSLA.\n3. Immediately after adding the equity, retrieve the TSLA `security` object.\n4. Check if the `security` object and its `fundamentals` property, specifically `financial_statements` and `cash_flow_statement`, are available.\n5. Access the TTM Operating Cash Flow (`financial_statements.cash_flow_statement.operating_cash_flow.twelve_months`) from the `fundamentals` data.\n6. Check if the Operating Cash Flow value is available (not None).\n7. If available, print the value using `self.log`; otherwise, print 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"TSLA\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `self.universe_settings.asynchronous = True` or `security.set_fundamentals_required(True)`).\n- Must access TTM Operating Cash Flow via `self.securities[\"TSLA\"].fundamentals.financial_statements.cash_flow_statement.operating_cash_flow.twelve_months`.\n- Must use `self.log()` for output within the `initialize` method.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only TSLA.\n- The TTM Operating Cash Flow fetching and printing must occur only once during the `initialize` phase, after the security and its fundamental data are likely available.\n- Print output format for available value: \"TSLA Initial Operating Cash Flow (TTM): [value]\"\n- Print output format for unavailable value: \"TSLA Initial Operating Cash Flow (TTM): N/A\"\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include nested checks immediately after `add_equity` to ensure the security object, `fundamentals`, `financial_statements`, and `cash_flow_statement` exist before accessing `operating_cash_flow.twelve_months`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (printing TSLA's latest TTM Operating Cash Flow at initialization).\n* Key setup steps in `initialize` (adding equity, enabling fundamental data).\n* Why the retrieval happens within `initialize`.\n* The specific API property used to access the TTM Operating Cash Flow.\n* How the algorithm performs nested checks for data availability before accessing the value.\n* How the algorithm handles cases where the value might be unavailable (printing 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0021", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that logs the Return on Assets (ROA) TTM for NVDA daily.\n\n**Core Logic Steps:**\n1. In `initialize`, add NVDA equity data with daily resolution and enable fundamental data.\n2. Schedule an event function (`log_roa`) to run daily, 40 minutes after market open for NVDA.\n3. In `log_roa`, get the NVDA `security` object.\n4. Check if the `security` object and its `fundamentals` property are available.\n5. Access the TTM Return on Assets (`operation_ratios.roa.one_year`) from the `fundamentals` data.\n6. Check if the retrieved ROA value is valid (not None).\n7. If valid, log the ROA using `self.log`; otherwise, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"NVDA\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.set_fundamentals_required(True)`).\n- Must use `self.schedule.on(self.date_rules.every_day(\"NVDA\"), self.time_rules.after_market_open(\"NVDA\", 40), self.log_roa)`.\n- Must access the ROA via `security.fundamentals.operation_ratios.roa.one_year`.\n- Must use `self.log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only NVDA.\n- Logging must occur exactly once per trading day, 40 minutes after NVDA's market open.\n- Log output format for available ROA: \"NVDA ROA (TTM): [value]\"\n- Log output format for unavailable ROA: \"NVDA ROA (TTM): N/A\"\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_roa`).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.fundamentals`) before accessing the ROA.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging NVDA's daily TTM ROA).\n* Key setup steps in `initialize` (adding equity, enabling fundamental data, scheduling).\n* How `schedule.on` triggers the daily logging after market open.\n* The specific API property used to access the TTM Return on Assets (`operation_ratios.roa.one_year`).\n* How the algorithm checks for data availability before accessing the ROA.\n* How the algorithm handles cases where the ROA might be unavailable (logging 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0022", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that plots the annual Gross Profit for JNJ when new fundamental data arrives.\n\n**Core Logic Steps:**\n1. In `initialize`, add JNJ equity data with daily resolution and enable fundamental data.\n2. Implement the `on_fundamentals` method (or equivalent logic in `on_data`).\n3. Store the JNJ symbol object in `initialize` (e.g., `self.jnj_symbol`).\n4. Create a `chart` named 'JNJ Annual Financials' and register a `series` named 'Gross Profit' in `initialize`.\n5. Inside the fundamental data handler, filter for the JNJ symbol.\n6. Access the annual Gross Profit (`financial_statements.income_statement.gross_profit.one_year`) from the fundamental data object.\n7. Check if the retrieved Gross Profit value is valid (not None).\n8. If valid, plot the value using the 'Gross Profit' series on the 'JNJ Annual Financials' chart.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"JNJ\", Resolution.Daily)`.\n- Must enable fundamental data reception (e.g., `security.set_fundamentals_required(True)` or `add_universe`).\n- Must handle fundamental data updates, preferably via `on_fundamentals(self, fine)`.\n- Must use `Chart('JNJ Annual Financials')` and `Series('Gross Profit', series_type.line, 0)` for plot setup.\n- Must access the annual Gross Profit via `.financial_statements.income_statement.gross_profit.one_year`.\n- Must use `self.plot('JNJ Annual Financials', 'Gross Profit', value)`.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only JNJ's fundamental updates.\n- Plotting must occur *only* when new fundamental data for JNJ is processed.\n- The plot must be named 'JNJ Annual Financials'.\n- The series must be named 'Gross Profit'.\n- Only plot valid Gross Profit figures (check for availability/None).\n\n**Essential Supporting Components:**\n- Include the `initialize` method with setup (data request, enabling fundamentals, plot creation, symbol storage).\n- Implement the method handling fundamental data updates (`on_fundamentals` or equivalent `on_data` logic).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks for data availability before plotting.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (plotting JNJ's annual Gross Profit upon fundamental updates).\n* Key setup steps in `initialize` (adding equity, enabling fundamentals, creating chart/series, storing symbol).\n* How fundamental data updates are captured and filtered for JNJ.\n* The specific API property used to access the *annual* Gross Profit.\n* How the `plot` function is used with the specified chart and series names.\n* How the algorithm checks for data validity before plotting.\n* The timing of when the plotting occurs."}
{"prompt_id": "FA-E-0023", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and log the Shares Outstanding for META daily.\n\n**Core Logic Steps:**\n1. In `initialize`, add META equity data with daily resolution and enable fundamental data.\n2. Schedule an event function (`log_shares_outstanding`) to run daily, 5 minutes after market open for META.\n3. In `log_shares_outstanding`, get the META `security` object.\n4. Check if the `security` object and its `fundamentals` property, specifically `company_profile`, are available.\n5. Access the Shares Outstanding (`company_profile.shares_outstanding`) from the `fundamentals` data.\n6. Check if the retrieved value is valid (not None and potentially > 0).\n7. If valid, log the value using `self.log`; otherwise, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"META\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.set_fundamentals_required(True)`).\n- Must use `self.schedule.on(self.date_rules.every_day(\"META\"), self.time_rules.after_market_open(\"META\", 5), self.log_shares_outstanding)`.\n- Must access Shares Outstanding via `security.fundamentals.company_profile.shares_outstanding`.\n- Must use `self.log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only META.\n- Logging must occur exactly once per trading day, 5 minutes after META's market open.\n- Log output format for available value: \"META Shares Outstanding: [value]\"\n- Log output format for unavailable value: \"META Shares Outstanding: N/A\"\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_shares_outstanding`).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include nested checks for data availability (`security`, `security.fundamentals`, `company_profile`) before accessing the value.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging META's daily Shares Outstanding).\n* Key setup steps in `initialize` (adding equity, enabling fundamental data, scheduling).\n* How `schedule.on` triggers the daily logging after market open.\n* The specific API property used to access Shares Outstanding (`company_profile.shares_outstanding`).\n* How the algorithm performs nested checks for data availability.\n* How the algorithm handles cases where the value might be unavailable (logging 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0024", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the CIK number for BRK.B during algorithm initialization.\n\n**Core Logic Steps:**\n1. In `initialize`, add BRK.B equity data with daily resolution.\n2. Enable fundamental data for BRK.B.\n3. Immediately after adding the equity, retrieve the BRK.B `security` object.\n4. Check if the `security` object and its `fundamentals` property, specifically `company_reference`, are available.\n5. Access the CIK number (`company_reference.cik`) from the `fundamentals` data.\n6. Check if the CIK value is available (not None or 0 or empty string).\n7. If available, print the CIK using `self.log`; otherwise, print 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"BRK.B\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `self.universe_settings.asynchronous = True` or `security.set_fundamentals_required(True)`).\n- Must access the CIK via `self.securities[\"BRK.B\"].fundamentals.company_reference.cik`.\n- Must use `self.log()` for output within the `initialize` method.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only BRK.B.\n- The CIK fetching and printing must occur only once during the `initialize` phase, after the security and its fundamental data are likely available.\n- Print output format for available CIK: \"BRK.B CIK: [value]\"\n- Print output format for unavailable CIK: \"BRK.B CIK: N/A\"\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include nested checks immediately after `add_equity` to ensure the security object, `fundamentals`, and `company_reference` exist before accessing `cik`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (printing BRK.B's CIK at initialization).\n* Key setup steps in `initialize` (adding equity, enabling fundamental data).\n* Why the CIK retrieval happens within `initialize`.\n* The specific API property used to access the CIK (`fundamentals.company_reference.cik`).\n* How the algorithm performs nested checks for data availability before accessing the value.\n* How the algorithm handles cases where the CIK might be unavailable (printing 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0025", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that retrieves and plots the Payout Ratio for V daily, if available.\n\n**Core Logic Steps:**\n1. In `initialize`, add V equity data with daily resolution and enable fundamental data.\n2. Create a `chart` named 'V Ratios' and register a `series` named 'Payout Ratio' associated with that chart.\n3. Schedule an event function (`plot_payout_ratio`) to run daily, 15 minutes after market open for V.\n4. In `plot_payout_ratio`, get the V `security` object.\n5. Check if the `security` object and its `fundamentals` property are available.\n6. Access the Payout Ratio (`operation_ratios.payout_ratio.one_year`) from the `fundamentals` data.\n7. Check if the retrieved ratio value is valid (not None).\n8. If valid, plot the ratio value using the 'Payout Ratio' series on the 'V Ratios' chart.\n9. If the ratio is not available, do not plot anything for that day.\n\n**Specific LEAN API Usage:**\n- Must use `self.add_equity(\"V\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.set_fundamentals_required(True)`).\n- Must use `Chart('V Ratios')` and `Series('Payout Ratio', series_type.line, 0)` for plot setup in `initialize`.\n- Must use `self.plot('V Ratios', 'Payout Ratio', value)` to plot the data *only* if the value is valid.\n- Must use `self.schedule.on(self.date_rules.every_day(\"V\"), self.time_rules.after_market_open(\"V\", 15), self.plot_payout_ratio)`.\n- Must access the Payout Ratio via `security.fundamentals.operation_ratios.payout_ratio.one_year`.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only V.\n- Plotting must be attempted exactly once per trading day, 15 minutes after market open.\n- The plot must be named 'V Ratios'.\n- The series must be named 'Payout Ratio'.\n- *Crucially*, only plot if the Payout Ratio value is available and not None. No plotting should occur if the data is missing for that day.\n\n**Essential Supporting Components:**\n- Include the `initialize` method with necessary setup (data request, enabling fundamentals, plot creation, scheduling).\n- Implement the scheduled event handler method (`plot_payout_ratio`).\n- Ensure the `qc_algorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.fundamentals`, and the specific ratio value) before attempting to plot.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (plotting V's Payout Ratio daily, only when available).\n* Key setup steps in `initialize` (adding equity, fundamental data, creating chart/series, scheduling).\n* How `schedule.on` triggers the daily plotting attempt.\n* The specific API property used to access the Payout Ratio (`operation_ratios.payout_ratio.one_year`).\n* How the `plot` function is used conditionally based on data availability.\n* The importance of the check for data availability (`value is not None`) before plotting.\n* How the algorithm handles missing data (by simply not plotting for that day)."}
{"prompt_id": "FA-E-0026", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that logs the Sales Per Share TTM for JPM every trading day.\n\n**Core Logic Steps:**\n1. In `Initialize`, add JPM equity data with daily resolution and enable fundamental data.\n2. Schedule an event function (`log_sps_ttm`) to run daily, 25 minutes after market open for JPM.\n3. In `log_sps_ttm`, get the JPM `Security` object.\n4. Check if the `Security` object and its `Fundamentals` property are available.\n5. Access the TTM Sales Per Share (`ValuationRatios.SalesPerShareTTM`) from the `Fundamentals` data.\n6. Check if the retrieved SPS value is valid (not None).\n7. If valid, log the SPS using `self.Log`; otherwise, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"JPM\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.SetFundamentalsRequired(True)`).\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"JPM\"), self.TimeRules.AfterMarketOpen(\"JPM\", 25), self.log_sps_ttm)`.\n- Must access the TTM SPS via `security.Fundamentals.ValuationRatios.SalesPerShareTTM`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only JPM.\n- Logging must occur exactly once per trading day, 25 minutes after JPM's market open.\n- Log output format for available SPS: \"JPM Sales Per Share (TTM): [value]\"\n- Log output format for unavailable SPS: \"JPM Sales Per Share (TTM): N/A\"\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_sps_ttm`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`) before accessing the SPS.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging JPM's daily TTM Sales Per Share).\n* Key setup steps in `Initialize` (adding equity, fundamental data, scheduling).\n* How `Schedule.On` triggers the daily logging after market open by calling `log_sps_ttm`.\n* The specific API property used to access the TTM Sales Per Share (`ValuationRatios.SalesPerShareTTM`).\n* How the algorithm checks for data availability before accessing the SPS.\n* How the algorithm handles cases where the SPS might be unavailable (logging 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0027", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and store the latest annual Total Liabilities for WMT in a variable.\n\n**Core Logic Steps:**\n1. In `Initialize`, add WMT equity data with daily resolution and enable fundamental data.\n2. Declare a class member variable `self.latest_total_liabilities` initialized to `None`.\n3. Implement the `OnFundamentals` method (or equivalent logic in `OnData`).\n4. Store the WMT symbol object in `Initialize` (e.g., `self.wmt_symbol`).\n5. Inside the fundamental data handler, filter for the WMT symbol.\n6. Access the annual Total Liabilities (`FinancialStatements.BalanceSheet.TotalLiabilities.OneYear`) from the fundamental data object.\n7. Check if the retrieved value is valid (not None).\n8. If valid, update `self.latest_total_liabilities` with the new value and log the update.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"WMT\", Resolution.Daily)`.\n- Must enable fundamental data reception (e.g., `security.SetFundamentalsRequired(True)` or `AddUniverse`).\n- Must handle fundamental data updates, preferably via `OnFundamentals(self, fine)`.\n- Must access the annual Total Liabilities via `.FinancialStatements.BalanceSheet.TotalLiabilities.OneYear`.\n- Must store the value in a class member variable named exactly `self.latest_total_liabilities`.\n- Must use `self.Log()` to confirm the update.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only WMT's fundamental updates.\n- The variable update must occur *only* when new fundamental data for WMT is processed.\n- The value must be stored in a class variable named `latest_total_liabilities`.\n- Log message on successful update: \"WMT Annual Total Liabilities updated to: [value] on [Date]\"\n- If the value is unavailable in an update, no update to the variable should occur, and no log message is required for this specific case.\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with setup (data request, enabling fundamentals, variable initialization, symbol storage).\n- Implement the method handling fundamental data updates (`OnFundamentals` or equivalent `OnData` logic).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include nested checks for data availability (`fine` or `security.Fundamentals`, `FinancialStatements`, `BalanceSheet`) before accessing the value and updating the variable.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (storing WMT's latest annual Total Liabilities upon fundamental update).\n* Key setup steps in `Initialize` (adding equity, enabling fundamentals, initializing `self.latest_total_liabilities`, storing symbol).\n* How fundamental data updates are captured and filtered for WMT using `OnFundamentals`.\n* The specific API property used to access the *annual* Total Liabilities.\n* How the retrieved value is stored in the required class variable `self.latest_total_liabilities`.\n* How the algorithm checks for data availability before accessing the value.\n* The timing of the variable update (only upon receiving new fundamental data).\n* The format of the log message upon successful update."}
{"prompt_id": "FA-E-0028", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the PEG Ratio for PG daily if the value is positive.\n\n**Core Logic Steps:**\n1. In `Initialize`, add PG equity data with daily resolution and enable fundamental data.\n2. Schedule an event function (`print_positive_peg_ratio`) to run daily, 50 minutes after market open for PG.\n3. In `print_positive_peg_ratio`, get the PG `Security` object.\n4. Check if the `Security` object and its `Fundamentals` property are available.\n5. Access the PEG Ratio (`ValuationRatios.PEGRatio`) from the `Fundamentals` data.\n6. Check if the retrieved PEG ratio is valid (not None) AND positive (> 0).\n7. If valid and positive, print the ratio using `self.Log`.\n8. If the ratio is not available, None, zero, or negative, do nothing (no print/log output).\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"PG\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.SetFundamentalsRequired(True)`).\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"PG\"), self.TimeRules.AfterMarketOpen(\"PG\", 50), self.print_positive_peg_ratio)`.\n- Must access the PEG ratio via `security.Fundamentals.ValuationRatios.PEGRatio`.\n- Must use `self.Log()` for printing the output *only* when the condition is met.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only PG.\n- The check must occur exactly once per trading day, 50 minutes after PG's market open.\n- Printing/logging must *only* occur if the PEG ratio is available, not None, AND strictly greater than 0.\n- Print output format if condition met: \"PG Positive PEG Ratio: [value]\"\n- No output should be generated if the PEG ratio is unavailable or not positive.\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`print_positive_peg_ratio`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the PEG ratio value itself) before applying the positivity check.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (printing PG's daily PEG ratio only if positive).\n* Key setup steps in `Initialize` (adding equity, enabling fundamental data, scheduling).\n* How the `Schedule.On` function is used to trigger the daily check by calling `print_positive_peg_ratio`.\n* The specific API property used to access the PEG ratio (`ValuationRatios.PEGRatio`).\n* The exact condition required for printing (`value is not None and value > 0`).\n* How the algorithm handles cases where the PEG ratio is unavailable or not positive (by doing nothing).\n* The format of the log output when the condition is met."}
{"prompt_id": "FA-E-0029", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that logs the Asset Turnover TTM for UNH daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, add UNH equity data with daily resolution and enable fundamental data.\n2. Schedule an event function (`log_asset_turnover`) to run daily, 1 hour before market close for UNH.\n3. In `log_asset_turnover`, get the UNH `Security` object.\n4. Check if the `Security` object and its `Fundamentals` property are available.\n5. Access the TTM Asset Turnover (`OperationRatios.AssetsTurnover.OneYear`) from the `Fundamentals` data.\n6. Check if the retrieved value is valid (not None).\n7. If valid, log the value using `self.Log`; otherwise, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"UNH\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.SetFundamentalsRequired(True)`).\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"UNH\"), self.TimeRules.BeforeMarketClose(\"UNH\", 60), self.log_asset_turnover)`.\n- Must access the TTM Asset Turnover via `security.Fundamentals.OperationRatios.AssetsTurnover.OneYear`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only UNH.\n- Logging must occur exactly once per trading day, 1 hour before UNH's market close.\n- Log output format for available value: \"UNH Asset Turnover (TTM): [value]\"\n- Log output format for unavailable value: \"UNH Asset Turnover (TTM): N/A\"\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_asset_turnover`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`) before accessing the value.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging UNH's daily TTM Asset Turnover).\n* Key setup steps in `Initialize` (adding equity, fundamental data, scheduling).\n* How `Schedule.On` triggers the daily logging before market close by calling `log_asset_turnover`.\n* The specific API property used to access the TTM Asset Turnover (`OperationRatios.AssetsTurnover.OneYear`).\n* How the algorithm checks for data availability before accessing the value.\n* How the algorithm handles cases where the value might be unavailable (logging 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0030", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that plots the EBITDA TTM for AAPL when fundamental data is updated.\n\n**Core Logic Steps:**\n1. In `Initialize`, add AAPL equity data with daily resolution and enable fundamental data.\n2. Implement the `OnFundamentals` method (or equivalent logic in `OnData`).\n3. Store the AAPL symbol object in `Initialize` (e.g., `self.aapl_symbol`).\n4. Create a `Chart` named 'AAPL Financials' and register a `Series` named 'EBITDA TTM' in `Initialize`.\n5. Inside the fundamental data handler, filter for the AAPL symbol.\n6. Access the TTM EBITDA (`FinancialStatements.IncomeStatement.EBITDA.TwelveMonths`) from the fundamental data object.\n7. Check if the retrieved EBITDA value is valid (not None).\n8. If valid, plot the value using the 'EBITDA TTM' series on the 'AAPL Financials' chart.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"AAPL\", Resolution.Daily)`.\n- Must enable fundamental data reception (e.g., `security.SetFundamentalsRequired(True)` or `AddUniverse`).\n- Must handle fundamental data updates, preferably via `OnFundamentals(self, fine)`.\n- Must use `Chart('AAPL Financials')` and `Series('EBITDA TTM', SeriesType.Line, 0)` for plot setup.\n- Must access the TTM EBITDA via `.FinancialStatements.IncomeStatement.EBITDA.TwelveMonths`.\n- Must use `self.Plot('AAPL Financials', 'EBITDA TTM', value)`.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only AAPL's fundamental updates.\n- Plotting must occur *only* when new fundamental data for AAPL is processed.\n- The plot must be named 'AAPL Financials'.\n- The series must be named 'EBITDA TTM'.\n- Only plot valid EBITDA figures (check for availability/None).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with setup (data request, enabling fundamentals, plot creation, symbol storage).\n- Implement the method handling fundamental data updates (`OnFundamentals` or equivalent `OnData` logic).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include nested checks for data availability before plotting.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (plotting AAPL's TTM EBITDA upon fundamental updates).\n* Key setup steps in `Initialize` (adding equity, enabling fundamentals, creating chart/series, storing symbol).\n* How fundamental data updates are captured and filtered for AAPL using `OnFundamentals`.\n* The specific API property used to access the *TTM* EBITDA.\n* How the `Plot` function is used with the specified chart and series names.\n* How the algorithm checks for data validity before plotting.\n* The timing of when the plotting occurs."}
{"prompt_id": "FA-E-0031", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and log the Net Margin TTM for MSFT daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, add MSFT equity data with daily resolution and enable fundamental data.\n2. Schedule an event function (`log_net_margin`) to run daily, 55 minutes after market open for MSFT.\n3. In `log_net_margin`, get the MSFT `Security` object.\n4. Check if the `Security` object and its `Fundamentals` property are available.\n5. Access the TTM Net Margin (`OperationRatios.NetMargin.OneYear`) from the `Fundamentals` data.\n6. Check if the retrieved margin value is valid (not None).\n7. If valid, log the value using `self.Log`; otherwise, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"MSFT\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.SetFundamentalsRequired(True)`).\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"MSFT\"), self.TimeRules.AfterMarketOpen(\"MSFT\", 55), self.log_net_margin)`.\n- Must access the TTM Net Margin via `security.Fundamentals.OperationRatios.NetMargin.OneYear`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only MSFT.\n- Logging must occur exactly once per trading day, 55 minutes after MSFT's market open.\n- Log output format for available margin: \"MSFT Net Margin (TTM): [value]\"\n- Log output format for unavailable margin: \"MSFT Net Margin (TTM): N/A\"\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_net_margin`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`) before accessing the value.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging MSFT's daily TTM Net Margin).\n* Key setup steps in `Initialize` (adding equity, fundamental data, scheduling).\n* How `Schedule.On` triggers the daily logging after market open by calling `log_net_margin`.\n* The specific API property used to access the TTM Net Margin (`OperationRatios.NetMargin.OneYear`).\n* How the algorithm checks for data availability before accessing the value.\n* How the algorithm handles cases where the value might be unavailable (logging 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0032", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the Country ID for GOOG during initialization.\n\n**Core Logic Steps:**\n1. In `Initialize`, add GOOG equity data with daily resolution.\n2. Enable fundamental data for GOOG.\n3. Immediately after adding the equity, retrieve the GOOG `Security` object.\n4. Check if the `Security` object and its `Fundamentals` property, specifically `CompanyReference`, are available.\n5. Access the Country ID (`CompanyReference.CountryId`) from the `Fundamentals` data.\n6. Check if the Country ID value is available (not None or empty string).\n7. If available, print the Country ID using `self.Log`; otherwise, print 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"GOOG\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `self.UniverseSettings.Asynchronous = True` or `security.SetFundamentalsRequired(True)`).\n- Must access the Country ID via `self.Securities[\"GOOG\"].Fundamentals.CompanyReference.CountryId`.\n- Must use `self.Log()` for output within the `Initialize` method.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only GOOG.\n- The Country ID fetching and printing must occur only once during the `Initialize` phase, after the security and its fundamental data are likely available.\n- Print output format for available ID: \"GOOG Country ID: [value]\"\n- Print output format for unavailable ID: \"GOOG Country ID: N/A\"\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (data request, enabling fundamentals).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include nested checks immediately after `AddEquity` to ensure the security object, `Fundamentals`, and `CompanyReference` exist before accessing `CountryId`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (printing GOOG's Country ID at initialization).\n* Key setup steps in `Initialize` (adding equity, enabling fundamental data).\n* Why the Country ID retrieval happens within `Initialize`.\n* The specific API property used to access the Country ID (`Fundamentals.CompanyReference.CountryId`).\n* How the algorithm performs nested checks for data availability before accessing the value.\n* How the algorithm handles cases where the ID might be unavailable (printing 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0033", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that retrieves and plots the Cash Return for AMZN daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, add AMZN equity data with daily resolution and enable fundamental data.\n2. Create a `Chart` named 'AMZN Ratios' and register a `Series` named 'Cash Return' associated with that chart.\n3. Schedule an event function (`plot_cash_return`) to run daily, at market close for AMZN.\n4. In `plot_cash_return`, get the AMZN `Security` object.\n5. Check if the `Security` object and its `Fundamentals` property are available.\n6. Access the TTM Cash Return (`OperationRatios.CashReturn.OneYear`) from the `Fundamentals` data.\n7. Check if the retrieved value is valid (not None).\n8. If valid, plot the value using the 'Cash Return' series on the 'AMZN Ratios' chart.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"AMZN\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.SetFundamentalsRequired(True)`).\n- Must use `Chart('AMZN Ratios')` and `Series('Cash Return', SeriesType.Line, 0)` for plot setup in `Initialize`.\n- Must use `self.Plot('AMZN Ratios', 'Cash Return', value)` to plot the data.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"AMZN\"), self.TimeRules.AtMarketClose(\"AMZN\"), self.plot_cash_return)`.\n- Must access the Cash Return via `security.Fundamentals.OperationRatios.CashReturn.OneYear`.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only AMZN.\n- Plotting must occur exactly once per trading day, at market close.\n- The plot must be named 'AMZN Ratios'.\n- The series must be named 'Cash Return'.\n- Only plot valid figures (must check if the value is available and not None).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (data request, enabling fundamentals, plot creation, scheduling).\n- Implement the scheduled event handler method (`plot_cash_return`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the specific value) before attempting to plot.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (plotting AMZN's TTM Cash Return daily).\n* Key setup steps in `Initialize` (adding equity, fundamental data, creating chart/series, scheduling).\n* How `Schedule.On` triggers the daily plotting at market close by calling `plot_cash_return`.\n* The specific API property used to access the TTM Cash Return (`OperationRatios.CashReturn.OneYear`).\n* How the `Plot` function is used with the specified chart and series names.\n* How the algorithm checks for data availability before attempting to access and plot the value.\n* Any assumptions made."}
{"prompt_id": "FA-E-0034", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that logs the Earnings Yield for TSLA every trading day.\n\n**Core Logic Steps:**\n1. In `Initialize`, add TSLA equity data with daily resolution and enable fundamental data.\n2. Schedule an event function (`log_earnings_yield`) to run daily, 35 minutes after market open for TSLA.\n3. In `log_earnings_yield`, get the TSLA `Security` object.\n4. Check if the `Security` object and its `Fundamentals` property are available.\n5. Access the Earnings Yield (`ValuationRatios.EarningsYield`) from the `Fundamentals` data.\n6. Check if the retrieved value is valid (not None).\n7. If valid, log the value using `self.Log`; otherwise, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"TSLA\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.SetFundamentalsRequired(True)`).\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"TSLA\"), self.TimeRules.AfterMarketOpen(\"TSLA\", 35), self.log_earnings_yield)`.\n- Must access the Earnings Yield via `security.Fundamentals.ValuationRatios.EarningsYield`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only TSLA.\n- Logging must occur exactly once per trading day, 35 minutes after TSLA's market open.\n- Log output format for available value: \"TSLA Earnings Yield: [value]\"\n- Log output format for unavailable value: \"TSLA Earnings Yield: N/A\"\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_earnings_yield`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`) before accessing the value.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging TSLA's daily Earnings Yield).\n* Key setup steps in `Initialize` (adding equity, fundamental data, scheduling).\n* How `Schedule.On` triggers the daily logging after market open by calling `log_earnings_yield`.\n* The specific API property used to access the Earnings Yield (`ValuationRatios.EarningsYield`).\n* How the algorithm checks for data availability before accessing the value.\n* How the algorithm handles cases where the value might be unavailable (logging 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0035", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and store the latest annual Research And Development expense for NVDA.\n\n**Core Logic Steps:**\n1. In `Initialize`, add NVDA equity data with daily resolution and enable fundamental data.\n2. Declare a class member variable `self.latest_rnd_expense` initialized to `None`.\n3. Implement the `OnFundamentals` method (or equivalent logic in `OnData`).\n4. Store the NVDA symbol object in `Initialize` (e.g., `self.nvda_symbol`).\n5. Inside the fundamental data handler, filter for the NVDA symbol.\n6. Access the annual R&D expense (`FinancialStatements.IncomeStatement.ResearchAndDevelopment.OneYear`) from the fundamental data object.\n7. Check if the retrieved value is valid (not None).\n8. If valid, update `self.latest_rnd_expense` with the new value and log the update.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"NVDA\", Resolution.Daily)`.\n- Must enable fundamental data reception (e.g., `security.SetFundamentalsRequired(True)` or `AddUniverse`).\n- Must handle fundamental data updates, preferably via `OnFundamentals(self, fine)`.\n- Must access the annual R&D expense via `.FinancialStatements.IncomeStatement.ResearchAndDevelopment.OneYear`.\n- Must store the value in a class member variable named exactly `self.latest_rnd_expense`.\n- Must use `self.Log()` to confirm the update.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only NVDA's fundamental updates.\n- The variable update must occur *only* when new fundamental data for NVDA is processed.\n- The value must be stored in a class variable named `latest_rnd_expense`.\n- Log message on successful update: \"NVDA Annual R&D Expense updated to: [value] on [Date]\"\n- If the value is unavailable in an update, no update to the variable should occur.\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with setup (data request, enabling fundamentals, variable initialization, symbol storage).\n- Implement the method handling fundamental data updates (`OnFundamentals` or equivalent `OnData` logic).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include nested checks for data availability before accessing the value and updating the variable.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (storing NVDA's latest annual R&D expense upon fundamental update).\n* Key setup steps in `Initialize` (adding equity, enabling fundamentals, initializing `self.latest_rnd_expense`, storing symbol).\n* How fundamental data updates are captured and filtered for NVDA using `OnFundamentals`.\n* The specific API property used to access the *annual* R&D expense.\n* How the retrieved value is stored in the required class variable `self.latest_rnd_expense`.\n* How the algorithm checks for data availability before accessing the value.\n* The timing of the variable update (only upon receiving new fundamental data).\n* The format of the log message upon successful update."}
{"prompt_id": "FA-E-0036", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the EV/EBITDA ratio for JNJ daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, add JNJ equity data with daily resolution and enable fundamental data.\n2. Schedule an event function (`print_ev_ebitda`) to run daily, 1 hour after market open for JNJ.\n3. In `print_ev_ebitda`, get the JNJ `Security` object.\n4. Check if the `Security` object and its `Fundamentals` property are available.\n5. Access the EV/EBITDA ratio (`ValuationRatios.ForwardEVEBITDA` or `ValuationRatios.EnterpriseValueEBITDA`) from the `Fundamentals` data. Choose one and specify it.\n6. Check if the retrieved value is valid (not None).\n7. If valid, print the value using `self.Log`; otherwise, print 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"JNJ\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.SetFundamentalsRequired(True)`).\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"JNJ\"), self.TimeRules.AfterMarketOpen(\"JNJ\", 60), self.print_ev_ebitda)`.\n- Must access the EV/EBITDA ratio via `security.Fundamentals.ValuationRatios.ForwardEVEBITDA` (or `EnterpriseValueEBITDA`).\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only JNJ.\n- Printing must occur exactly once per trading day, 1 hour after JNJ's market open.\n- Use `ForwardEVEBITDA` specifically.\n- Print output format for available value: \"JNJ Forward EV/EBITDA: [value]\"\n- Print output format for unavailable value: \"JNJ Forward EV/EBITDA: N/A\"\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`print_ev_ebitda`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`) before accessing the value.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (printing JNJ's daily Forward EV/EBITDA ratio).\n* Key setup steps in `Initialize` (adding equity, fundamental data, scheduling).\n* How `Schedule.On` triggers the daily printing after market open by calling `print_ev_ebitda`.\n* The specific API property used (`ValuationRatios.ForwardEVEBITDA`).\n* How the algorithm checks for data availability before accessing the value.\n* How the algorithm handles cases where the value might be unavailable (printing 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0037", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that logs the Inventory Turnover TTM for META daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, add META equity data with daily resolution and enable fundamental data.\n2. Schedule an event function (`log_inventory_turnover`) to run daily, 20 minutes before market close for META.\n3. In `log_inventory_turnover`, get the META `Security` object.\n4. Check if the `Security` object and its `Fundamentals` property are available.\n5. Access the TTM Inventory Turnover (`OperationRatios.InventoryTurnover.OneYear`) from the `Fundamentals` data.\n6. Check if the retrieved value is valid (not None).\n7. If valid, log the value using `self.Log`; otherwise, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"META\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.SetFundamentalsRequired(True)`).\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"META\"), self.TimeRules.BeforeMarketClose(\"META\", 20), self.log_inventory_turnover)`.\n- Must access the TTM Inventory Turnover via `security.Fundamentals.OperationRatios.InventoryTurnover.OneYear`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only META.\n- Logging must occur exactly once per trading day, 20 minutes before META's market close.\n- Log output format for available value: \"META Inventory Turnover (TTM): [value]\"\n- Log output format for unavailable value: \"META Inventory Turnover (TTM): N/A\"\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_inventory_turnover`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`) before accessing the value.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging META's daily TTM Inventory Turnover).\n* Key setup steps in `Initialize` (adding equity, fundamental data, scheduling).\n* How `Schedule.On` triggers the daily logging before market close by calling `log_inventory_turnover`.\n* The specific API property used (`OperationRatios.InventoryTurnover.OneYear`).\n* How the algorithm checks for data availability before accessing the value.\n* How the algorithm handles cases where the value might be unavailable (logging 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0038", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that plots the Free Cash Flow Yield (FCFYield) for BRK.B daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, add BRK.B equity data with daily resolution and enable fundamental data.\n2. Create a `Chart` named 'BRK.B Yields' and register a `Series` named 'FCF Yield' associated with that chart.\n3. Schedule an event function (`plot_fcf_yield`) to run daily, at market close for BRK.B.\n4. In `plot_fcf_yield`, get the BRK.B `Security` object.\n5. Check if the `Security` object and its `Fundamentals` property are available.\n6. Access the FCF Yield (`ValuationRatios.FCFYield`) from the `Fundamentals` data.\n7. Check if the retrieved value is valid (not None).\n8. If valid, plot the value using the 'FCF Yield' series on the 'BRK.B Yields' chart.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"BRK.B\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.SetFundamentalsRequired(True)`).\n- Must use `Chart('BRK.B Yields')` and `Series('FCF Yield', SeriesType.Line, 0)` for plot setup in `Initialize`.\n- Must use `self.Plot('BRK.B Yields', 'FCF Yield', value)` to plot the data.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"BRK.B\"), self.TimeRules.AtMarketClose(\"BRK.B\"), self.plot_fcf_yield)`.\n- Must access the FCF Yield via `security.Fundamentals.ValuationRatios.FCFYield`.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only BRK.B.\n- Plotting must occur exactly once per trading day, at market close.\n- The plot must be named 'BRK.B Yields'.\n- The series must be named 'FCF Yield'.\n- Only plot valid figures (must check if the value is available and not None).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (data request, enabling fundamentals, plot creation, scheduling).\n- Implement the scheduled event handler method (`plot_fcf_yield`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the specific value) before attempting to plot.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (plotting BRK.B's FCF Yield daily).\n* Key setup steps in `Initialize` (adding equity, fundamental data, creating chart/series, scheduling).\n* How `Schedule.On` triggers the daily plotting at market close by calling `plot_fcf_yield`.\n* The specific API property used to access the FCF Yield (`ValuationRatios.FCFYield`).\n* How the `Plot` function is used with the specified chart and series names.\n* How the algorithm checks for data availability before attempting to access and plot the value.\n* Any assumptions made."}
{"prompt_id": "FA-E-0039", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and log the Price/Cash Flow Per Share Ratio (PCFSRatio) for V daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, add V equity data with daily resolution and enable fundamental data.\n2. Schedule an event function (`log_pcfs_ratio`) to run daily, 45 minutes before market close for V.\n3. In `log_pcfs_ratio`, get the V `Security` object.\n4. Check if the `Security` object and its `Fundamentals` property are available.\n5. Access the Price/Cash Flow Per Share Ratio (`ValuationRatios.PCFSRatio`) from the `Fundamentals` data.\n6. Check if the retrieved value is valid (not None).\n7. If valid, log the value using `self.Log`; otherwise, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"V\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.SetFundamentalsRequired(True)`).\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"V\"), self.TimeRules.BeforeMarketClose(\"V\", 45), self.log_pcfs_ratio)`.\n- Must access the ratio via `security.Fundamentals.ValuationRatios.PCFSRatio`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only V.\n- Logging must occur exactly once per trading day, 45 minutes before V's market close.\n- Log output format for available value: \"V PCFS Ratio: [value]\"\n- Log output format for unavailable value: \"V PCFS Ratio: N/A\"\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_pcfs_ratio`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`) before accessing the value.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging V's daily Price/Cash Flow Per Share Ratio).\n* Key setup steps in `Initialize` (adding equity, fundamental data, scheduling).\n* How `Schedule.On` triggers the daily logging before market close by calling `log_pcfs_ratio`.\n* The specific API property used (`ValuationRatios.PCFSRatio`).\n* How the algorithm checks for data availability before accessing the value.\n* How the algorithm handles cases where the value might be unavailable (logging 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0040", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the Headquarters City for JPM during initialization.\n\n**Core Logic Steps:**\n1. In `Initialize`, add JPM equity data with daily resolution.\n2. Enable fundamental data for JPM.\n3. Immediately after adding the equity, retrieve the JPM `Security` object.\n4. Check if the `Security` object and its `Fundamentals` property, specifically `CompanyProfile`, are available.\n5. Access the Headquarters City (`CompanyProfile.HeadQuarterCity`) from the `Fundamentals` data.\n6. Check if the City value is available (not None or empty string).\n7. If available, print the City using `self.Log`; otherwise, print 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"JPM\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `self.UniverseSettings.Asynchronous = True` or `security.SetFundamentalsRequired(True)`).\n- Must access the City via `self.Securities[\"JPM\"].Fundamentals.CompanyProfile.HeadQuarterCity`.\n- Must use `self.Log()` for output within the `Initialize` method.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only JPM.\n- The City fetching and printing must occur only once during the `Initialize` phase, after the security and its fundamental data are likely available.\n- Print output format for available city: \"JPM Headquarters City: [value]\"\n- Print output format for unavailable city: \"JPM Headquarters City: N/A\"\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (data request, enabling fundamentals).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include nested checks immediately after `AddEquity` to ensure the security object, `Fundamentals`, and `CompanyProfile` exist before accessing `HeadQuarterCity`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (printing JPM's Headquarters City at initialization).\n* Key setup steps in `Initialize` (adding equity, enabling fundamental data).\n* Why the City retrieval happens within `Initialize`.\n* The specific API property used (`Fundamentals.CompanyProfile.HeadQuarterCity`).\n* How the algorithm performs nested checks for data availability before accessing the value.\n* How the algorithm handles cases where the city might be unavailable (printing 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0041", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that retrieves and logs the annual Interest Expense for WMT.\n\n**Core Logic Steps:**\n1. In `Initialize`, add WMT equity data with daily resolution and enable fundamental data.\n2. Implement the `OnFundamentals` method (or equivalent logic in `OnData`).\n3. Store the WMT symbol object in `Initialize` (e.g., `self.wmt_symbol`).\n4. Inside the fundamental data handler, filter for the WMT symbol.\n5. Access the annual Interest Expense (`FinancialStatements.IncomeStatement.InterestExpense.OneYear`) from the fundamental data object.\n6. Check if the retrieved value is valid (not None).\n7. If valid, log the value using `self.Log` with a specific format.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"WMT\", Resolution.Daily)`.\n- Must enable fundamental data reception (e.g., `security.SetFundamentalsRequired(True)` or `AddUniverse`).\n- Must handle fundamental data updates, preferably via `OnFundamentals(self, fine)`.\n- Must access the annual Interest Expense via `.FinancialStatements.IncomeStatement.InterestExpense.OneYear`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only WMT's fundamental updates.\n- Logging must occur *only* when new fundamental data containing the annual Interest Expense for WMT is processed.\n- Log output format: \"WMT Annual Interest Expense (Updated [Date]): [value]\"\n- Only log valid figures (check for availability/None).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with setup (data request, enabling fundamentals, symbol storage).\n- Implement the method handling fundamental data updates (`OnFundamentals` or equivalent `OnData` logic).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include nested checks for data availability before logging.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging WMT's annual Interest Expense upon fundamental updates).\n* Key setup steps in `Initialize` (adding equity, enabling fundamentals, storing symbol).\n* How fundamental data updates are captured and filtered for WMT using `OnFundamentals`.\n* The specific API property used to access the *annual* Interest Expense.\n* How the `Log` function is used with the specified format.\n* How the algorithm checks for data validity before logging.\n* The timing of when the logging occurs (upon fundamental update arrival)."}
{"prompt_id": "FA-E-0042", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that plots the Price Fair Value (Morningstar) for PG daily, if available.\n\n**Core Logic Steps:**\n1. In `Initialize`, add PG equity data with daily resolution and enable fundamental data.\n2. Create a `Chart` named 'PG Valuation' and register a `Series` named 'Morningstar Fair Value' associated with that chart.\n3. Schedule an event function (`plot_fair_value`) to run daily, 30 minutes after market open for PG.\n4. In `plot_fair_value`, get the PG `Security` object.\n5. Check if the `Security` object and its `Fundamentals` property, specifically `ValuationRatios`, are available.\n6. Access the Morningstar Fair Value (`ValuationRatios.MorningstarFairValue`) from the `Fundamentals` data.\n7. Check if the retrieved value is valid (not None and potentially > 0).\n8. If valid, plot the value using the 'Morningstar Fair Value' series on the 'PG Valuation' chart.\n9. If the value is not available, do not plot anything for that day.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"PG\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.SetFundamentalsRequired(True)`).\n- Must use `Chart('PG Valuation')` and `Series('Morningstar Fair Value', SeriesType.Line, 0)` for plot setup in `Initialize`.\n- Must use `self.Plot('PG Valuation', 'Morningstar Fair Value', value)` to plot the data *only* if the value is valid.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"PG\"), self.TimeRules.AfterMarketOpen(\"PG\", 30), self.plot_fair_value)`.\n- Must access the value via `security.Fundamentals.ValuationRatios.MorningstarFairValue`.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only PG.\n- Plotting must be attempted exactly once per trading day, 30 minutes after market open.\n- The plot must be named 'PG Valuation'.\n- The series must be named 'Morningstar Fair Value'.\n- *Crucially*, only plot if the Fair Value is available, not None, and greater than 0. No plotting if data is missing or invalid.\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (data request, enabling fundamentals, plot creation, scheduling).\n- Implement the scheduled event handler method (`plot_fair_value`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, `ValuationRatios`, and the value itself) before attempting to plot.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (plotting PG's Morningstar Fair Value daily, only when available and valid).\n* Key setup steps in `Initialize` (adding equity, fundamental data, creating chart/series, scheduling).\n* How `Schedule.On` triggers the daily plotting attempt by calling `plot_fair_value`.\n* The specific API property used (`ValuationRatios.MorningstarFairValue`).\n* How the `Plot` function is used conditionally based on data availability and validity (`value is not None and value > 0`).\n* How the algorithm handles missing or invalid data (by not plotting).\n* A note about the source and potential availability of Morningstar data."}
{"prompt_id": "FA-E-0043", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and store the latest TTM Selling, General & Administrative (SG&A) expense for UNH.\n\n**Core Logic Steps:**\n1. In `Initialize`, add UNH equity data with daily resolution and enable fundamental data.\n2. Declare a class member variable `self.latest_sga_expense_ttm` initialized to `None`.\n3. Implement the `OnFundamentals` method (or equivalent logic in `OnData`).\n4. Store the UNH symbol object in `Initialize` (e.g., `self.unh_symbol`).\n5. Inside the fundamental data handler, filter for the UNH symbol.\n6. Access the TTM SG&A expense (`FinancialStatements.IncomeStatement.SellingGeneralAndAdministration.TwelveMonths`) from the fundamental data object.\n7. Check if the retrieved value is valid (not None).\n8. If valid, update `self.latest_sga_expense_ttm` with the new value and log the update.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"UNH\", Resolution.Daily)`.\n- Must enable fundamental data reception (e.g., `security.SetFundamentalsRequired(True)` or `AddUniverse`).\n- Must handle fundamental data updates, preferably via `OnFundamentals(self, fine)`.\n- Must access the TTM SG&A expense via `.FinancialStatements.IncomeStatement.SellingGeneralAndAdministration.TwelveMonths`.\n- Must store the value in a class member variable named exactly `self.latest_sga_expense_ttm`.\n- Must use `self.Log()` to confirm the update.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only UNH's fundamental updates.\n- The variable update must occur *only* when new fundamental data for UNH is processed.\n- The value must be stored in a class variable named `latest_sga_expense_ttm`.\n- Log message on successful update: \"UNH SG&A Expense (TTM) updated to: [value] on [Date]\"\n- If the value is unavailable in an update, no update to the variable should occur.\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with setup (data request, enabling fundamentals, variable initialization, symbol storage).\n- Implement the method handling fundamental data updates (`OnFundamentals` or equivalent `OnData` logic).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include nested checks for data availability before accessing the value and updating the variable.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (storing UNH's latest TTM SG&A expense upon fundamental update).\n* Key setup steps in `Initialize` (adding equity, enabling fundamentals, initializing `self.latest_sga_expense_ttm`, storing symbol).\n* How fundamental data updates are captured and filtered for UNH using `OnFundamentals`.\n* The specific API property used to access the *TTM* SG&A expense.\n* How the retrieved value is stored in the required class variable `self.latest_sga_expense_ttm`.\n* How the algorithm checks for data availability before accessing the value.\n* The timing of the variable update (only upon receiving new fundamental data).\n* The format of the log message upon successful update."}
{"prompt_id": "FA-E-0044", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the Revenue Growth (3 year average) for AAPL daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, add AAPL equity data with daily resolution and enable fundamental data.\n2. Schedule an event function (`print_revenue_growth`) to run daily, 10 minutes before market close for AAPL.\n3. In `print_revenue_growth`, get the AAPL `Security` object.\n4. Check if the `Security` object and its `Fundamentals` property, specifically `OperationRatios`, are available.\n5. Access the 3-Year Revenue Growth (`OperationRatios.RevenueGrowth.ThreeYears`) from the `Fundamentals` data.\n6. Check if the retrieved value is valid (not None).\n7. If valid, print the value using `self.Log`; otherwise, print 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"AAPL\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.SetFundamentalsRequired(True)`).\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"AAPL\"), self.TimeRules.BeforeMarketClose(\"AAPL\", 10), self.print_revenue_growth)`.\n- Must access the 3Y Revenue Growth via `security.Fundamentals.OperationRatios.RevenueGrowth.ThreeYears`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only AAPL.\n- Printing must occur exactly once per trading day, 10 minutes before AAPL's market close.\n- Print output format for available value: \"AAPL Revenue Growth (3Y Avg): [value]\"\n- Print output format for unavailable value: \"AAPL Revenue Growth (3Y Avg): N/A\"\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`print_revenue_growth`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include nested checks for data availability (`security`, `security.Fundamentals`, `OperationRatios`) before accessing the value.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (printing AAPL's daily 3-Year Average Revenue Growth).\n* Key setup steps in `Initialize` (adding equity, fundamental data, scheduling).\n* How `Schedule.On` triggers the daily printing before market close by calling `print_revenue_growth`.\n* The specific API property used (`OperationRatios.RevenueGrowth.ThreeYears`).\n* How the algorithm checks for data availability before accessing the value.\n* How the algorithm handles cases where the value might be unavailable (printing 'N/A').\n* The format of the log output."}
{"prompt_id": "FA-E-0045", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that logs the annual Capital Expenditures for MSFT when fundamental data arrives.\n\n**Core Logic Steps:**\n1. In `Initialize`, add MSFT equity data with daily resolution and enable fundamental data.\n2. Implement the `OnFundamentals` method (or equivalent logic in `OnData`).\n3. Store the MSFT symbol object in `Initialize` (e.g., `self.msft_symbol`).\n4. Inside the fundamental data handler, filter for the MSFT symbol.\n5. Access the annual Capital Expenditures (`FinancialStatements.CashFlowStatement.CapitalExpenditure.OneYear`) from the fundamental data object.\n6. Check if the retrieved value is valid (not None).\n7. If valid, log the value using `self.Log` with a specific format.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"MSFT\", Resolution.Daily)`.\n- Must enable fundamental data reception (e.g., `security.SetFundamentalsRequired(True)` or `AddUniverse`).\n- Must handle fundamental data updates, preferably via `OnFundamentals(self, fine)`.\n- Must access the annual CapEx via `.FinancialStatements.CashFlowStatement.CapitalExpenditure.OneYear`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only MSFT's fundamental updates.\n- Logging must occur *only* when new fundamental data containing the annual CapEx for MSFT is processed.\n- Log output format: \"MSFT Annual Capital Expenditures (Updated [Date]): [value]\"\n- Only log valid figures (check for availability/None).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with setup (data request, enabling fundamentals, symbol storage).\n- Implement the method handling fundamental data updates (`OnFundamentals` or equivalent `OnData` logic).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include nested checks for data availability before logging.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging MSFT's annual CapEx upon fundamental updates).\n* Key setup steps in `Initialize` (adding equity, enabling fundamentals, storing symbol).\n* How fundamental data updates are captured and filtered for MSFT using `OnFundamentals`.\n* The specific API property used to access the *annual* Capital Expenditures.\n* How the `Log` function is used with the specified format.\n* How the algorithm checks for data validity before logging.\n* The timing of when the logging occurs (upon fundamental update arrival)."}
{"prompt_id": "FA-E-0046", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that plots the Price Change 1 Month for GOOG daily.\n\-n**Core Logic Steps:**\n1. In `Initialize`, add GOOG equity data with daily resolution and enable fundamental data (needed for performance metrics).\n2. Create a `Chart` named 'GOOG Performance' and register a `Series` named 'Price Change 1M' associated with that chart.\n3. Schedule an event function (`PlotPriceChange1M`) to run daily, at market open for GOOG.\n4. In `PlotPriceChange1M`, get the GOOG `Security` object.\n5. Check if the `Security` object and its `Fundamentals` property, specifically `PerformanceRatios`, are available.\n6. Access the 1-Month Price Change (`PerformanceRatios.OneMonthPriceChange`) from the `Fundamentals` data.\n7. Check if the retrieved value is valid (not None).\n8. If valid, plot the value (which is typically a percentage) using the 'Price Change 1M' series on the 'GOOG Performance' chart.\n\n**Specific LEAN API Usage:**\n- Must use `self.AddEquity(\"GOOG\", Resolution.Daily)`.\n- Must enable fundamental data (e.g., `security.SetFundamentalsRequired(True)`).\n- Must use `Chart('GOOG Performance')` and `Series('Price Change 1M', SeriesType.Line, 0)` for plot setup in `Initialize`.\n- Must use `self.Plot('GOOG Performance', 'Price Change 1M', value)` to plot the data.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"GOOG\"), self.TimeRules.AtMarketOpen(\"GOOG\"), self.PlotPriceChange1M)`.\n- Must access the value via `security.Fundamentals.PerformanceRatios.OneMonthPriceChange`.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only GOOG.\n- Plotting must occur exactly once per trading day, at market open.\n- The plot must be named 'GOOG Performance'.\n- The series must be named 'Price Change 1M'.\n- Only plot valid figures (must check if the value is available and not None).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (data request, enabling fundamentals, plot creation, scheduling).\n- Implement the scheduled event handler method (`PlotPriceChange1M`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, `PerformanceRatios`, and the value itself) before attempting to plot.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (plotting GOOG's 1-Month Price Change daily).\n* Key setup steps in `Initialize` (adding equity, fundamental data, creating chart/series, scheduling).\n* How `Schedule.On` triggers the daily plotting at market open.\n* The specific API property used (`PerformanceRatios.OneMonthPriceChange`).\n* How the `Plot` function is used with the specified chart and series names.\n* How the algorithm checks for data availability before attempting to access and plot the value.\n* Any assumptions made (e.g., data represents percentage change)." }
{"prompt_id": "FA-E-0047", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm that performs the following steps:\n1. Initialize the algorithm: Set start and end dates (e.g., 2020-01-01 to 2023-01-01). Set starting cash (e.g., $100,000).\n2. Request daily resolution data for the specific equity 'AMZN' using `AddEquity`.\n3. Request fundamental data for 'AMZN' by setting `self.UniverseSettings.Resolution = Resolution.Daily` and implementing `OnData`.\n4. In `OnData`, access the `FineFundamental` object for the AMZN equity.\n5. Check if fundamental data is available using `fine.HasFundamentalData`.\n6. If data is available, retrieve the latest annual Cost of Revenue using `fine.FinancialStatements.IncomeStatement.CostOfRevenue.TwelveMonths`.\n7. Log the retrieved value daily using `self.Log()` with the specific format: 'YYYY-MM-DD: AMZN Cost of Revenue (Annual/TTM): [Value]'.\n8. Ensure the `Initialize` method contains the necessary setup (cash, dates, `AddEquity` for AMZN, setting fundamental data resolution).\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Fetching and logging AMZN's annual Cost of Revenue.\n* Key setup in `Initialize`: Requesting AMZN data (`AddEquity`), setting universe resolution for fundamentals.\n* Core Logic in `OnData`: How `FineFundamental` is accessed, checking `fine.HasFundamentalData`.\n* Specific API Usage: How `fine.FinancialStatements.IncomeStatement.CostOfRevenue.TwelveMonths` is used to get the specific data point.\n* Constraints Met: How the daily logging and specific log format constraint are implemented.\n* Supporting Components: Mentioning the check for data availability (`fine.HasFundamentalData`).\n* Any assumptions made (e.g., using TTM as the latest annual figure available daily)."}
{"prompt_id": "FA-E-0048", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script that performs the following steps:\n1. Initialize the algorithm: Set start and end dates (e.g., 2021-01-01 to 2023-01-01). Set starting cash (e.g., $100,000).\n2. Request daily resolution data for the specific equity 'TSLA' using `AddEquity`.\n3. Request fundamental data for 'TSLA' by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n4. Implement the `OnData` method to receive daily data updates.\n5. Inside `OnData`, access the `FineFundamental` object for the TSLA equity.\n6. Check if fundamental data is available using `fine.HasFundamentalData`.\n7. If data is available, retrieve the latest Return on Invested Capital (ROIC) TTM using `fine.OperationRatios.ROIC.Value`.\n8. Print the retrieved ROIC value daily using `self.Log()` (or `print()`, but `Log` is preferred for backtesting clarity) with the specific format: 'TSLA ROIC (TTM): [Value]'.\n9. Ensure the `Initialize` method contains necessary setup (`AddEquity`, setting fundamental resolution).\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Printing TSLA's latest TTM ROIC daily.\n* Key setup in `Initialize`: How 'TSLA' equity data and fundamentals are requested using `AddEquity` and `self.UniverseSettings.Resolution`.\n* Core Logic in `OnData`: How the `FineFundamental` object is accessed and checked for availability (`fine.HasFundamentalData`).\n* Specific API Usage: How `fine.OperationRatios.ROIC.Value` is used to retrieve the TTM ROIC.\n* Constraints Met: How the daily printing/logging and the specific output format are implemented.\n* Supporting Components: Explanation of the `fine.HasFundamentalData` check.\n* Any assumptions made."}
{"prompt_id": "FA-E-0049", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that performs the following steps:\n1. Initialize the algorithm: Set start and end dates (e.g., 2021-01-01 to 2023-01-01). Set starting cash (e.g., $100,000).\n2. Request daily resolution data for the specific equity 'NVDA' using `AddEquity`.\n3. Request fundamental data for 'NVDA' by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n4. Implement the `OnData` method.\n5. In `OnData`, access the `FineFundamental` object for NVDA.\n6. Check if fundamental data is available using `fine.HasFundamentalData`.\n7. If data is available, retrieve the Pretax Margin TTM using `fine.OperationRatios.PretaxMargin.Value`.\n8. Log the retrieved value daily using `self.Log()` with the format: 'NVDA Pretax Margin TTM: [Value]'.\n9. Ensure the `Initialize` method includes `AddEquity('NVDA')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Retrieving and logging NVDA's TTM Pretax Margin daily.\n* Key setup in `Initialize`: Requesting NVDA data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental` and checking for data availability.\n* Specific API Usage: How `fine.OperationRatios.PretaxMargin.Value` is used.\n* Constraints Met: How daily logging and the specified format are achieved.\n* Supporting Components: The importance of the `fine.HasFundamentalData` check.\n* Any assumptions made."}
{"prompt_id": "FA-E-0050", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that performs the following steps:\n1. Initialize the algorithm: Set start and end dates (e.g., 2018-01-01 to 2023-01-01). Set starting cash.\n2. Request daily resolution data for the equity 'JNJ' using `AddEquity`.\n3. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n4. In `Initialize`, create a `Chart` object named 'Annual Income Tax Expense'.\n5. In `Initialize`, create a `Series` named 'JNJ Income Tax' for the chart, specifying series type (e.g., line or scatter).\n6. Implement the `OnData` method.\n7. In `OnData`, access the `FineFundamental` object for JNJ.\n8. Check if fundamental data is available (`fine.HasFundamentalData`).\n9. Retrieve the annual Income Tax Expense using `fine.FinancialStatements.IncomeStatement.IncomeTaxExpense.TwelveMonths` (or `.OneMonth` if plotting monthly updates of the annual value is acceptable).\n10. Use `self.Plot()` method daily inside the `if fine.HasFundamentalData:` block to plot the retrieved value on the 'Annual Income Tax Expense' chart under the 'JNJ Income Tax' series.\n11. Ensure `Initialize` includes `AddEquity('JNJ')`, fundamental resolution setting, and chart setup.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Plotting the annual Income Tax Expense for JNJ.\n* Key setup in `Initialize`: Requesting JNJ data/fundamentals, setting up the `Chart` and `Series` objects using `Chart()` and `Series()`.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.IncomeStatement.IncomeTaxExpense.TwelveMonths` is used to get the data and how `self.Plot()` is used to visualize it daily.\n* Constraints Met: How the plotting is done daily for the specified metric (annual/TTM value).\n* Supporting Components: The necessity of the `fine.HasFundamentalData` check before plotting.\n* Any assumptions made (e.g., plotting the latest TTM value daily)."}
{"prompt_id": "FA-E-0051", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add the 'META' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Declare a class member variable (e.g., `self.latest_cash_equivalents = None`) in `Initialize` to store the value.\n4. Implement the `OnData` method.\n5. In `OnData`, access the `FineFundamental` object for META.\n6. Check for data availability using `fine.HasFundamentalData`.\n7. If data is available, retrieve the latest Cash And Cash Equivalents value using `fine.FinancialStatements.BalanceSheet.CashAndCashEquivalents.Value` (assuming `.Value` accesses the latest reported figure).\n8. Update the class member variable: `self.latest_cash_equivalents = retrieved_value`.\n9. Optionally, log the update: `self.Log(f'Updated META Cash And Cash Equivalents: {self.latest_cash_equivalents}')`.\n10. Ensure `Initialize` sets up the equity request, fundamental resolution, and the storage variable.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Fetching and storing the latest Cash And Cash Equivalents for META.\n* Key setup in `Initialize`: Requesting META data/fundamentals and initializing the storage variable (`self.latest_cash_equivalents`).\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.BalanceSheet.CashAndCashEquivalents.Value` is used to get the data.\n* Constraints Met: How the value is stored in a class variable upon availability.\n* Supporting Components: The use of `fine.HasFundamentalData` and the initialization of the storage variable.\n* Any assumptions made (e.g., `Value` property gives the latest reported balance sheet figure)."}
{"prompt_id": "FA-E-0052", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script that performs the following steps:\n1. Initialize the algorithm: Set start/end dates (a short period is fine, e.g., 2 days in 2023). Set cash.\n2. Request daily resolution data for 'BRK.B' using `AddEquity`.\n3. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n4. Implement the `OnData` method.\n5. Use a flag (e.g., `self.goodwill_printed = False`) initialized to `False` in `Initialize` to ensure the value is printed only once.\n6. In `OnData`, check if `self.goodwill_printed` is `False`.\n7. Inside this check, access the `FineFundamental` object for BRK.B.\n8. Check if fundamental data is available using `fine.HasFundamentalData`.\n9. If data is available, retrieve the Goodwill value from the latest balance sheet using `fine.FinancialStatements.BalanceSheet.Goodwill.Value`.\n10. Print the value using `self.Log()` with the format: 'BRK.B Goodwill (Latest): [Value]'.\n11. Set the flag `self.goodwill_printed = True` after printing.\n12. Ensure `Initialize` includes `AddEquity('BRK.B')`, fundamental resolution setting, and the flag initialization.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Printing the latest Goodwill value for BRK.B once during initialization/first data arrival.\n* Key setup in `Initialize`: Requesting BRK.B data/fundamentals, initializing the `self.goodwill_printed` flag.\n* Core Logic in `OnData`: How the flag (`self.goodwill_printed`) is used to ensure single execution, accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.BalanceSheet.Goodwill.Value` is used.\n* Constraints Met: How the value is printed only once using the flag mechanism and the specific log format.\n* Supporting Components: The `fine.HasFundamentalData` check and the role of the boolean flag.\n* Any assumptions made (that fundamental data will be available within the algorithm's runtime)."}
{"prompt_id": "FA-E-0053", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'V' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for V.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the Long Term Debt value using `fine.FinancialStatements.BalanceSheet.LongTermDebt.Value`.\n7. Log the retrieved value daily using `self.Log()` with the format: 'V Long Term Debt: [Value]'.\n8. Ensure `Initialize` contains `AddEquity('V')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Logging the Long Term Debt value for V daily.\n* Key setup in `Initialize`: Requesting V data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental` and checking for data availability.\n* Specific API Usage: How `fine.FinancialStatements.BalanceSheet.LongTermDebt.Value` is used.\n* Constraints Met: How daily logging and the specific format are implemented.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made."}
{"prompt_id": "FA-E-0054", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'JPM' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. In `Initialize`, create a `Chart` named 'JPM Balance Sheet'.\n4. In `Initialize`, create a `Series` named 'Retained Earnings' for the chart.\n5. Implement the `OnData` method.\n6. In `OnData`, access the `FineFundamental` object for JPM.\n7. Check for data availability (`fine.HasFundamentalData`).\n8. If data is available, retrieve the Retained Earnings value from the latest balance sheet update using `fine.FinancialStatements.BalanceSheet.RetainedEarnings.Value`.\n9. Use `self.Plot()` method inside the `if fine.HasFundamentalData:` block to plot the retrieved value on the 'JPM Balance Sheet' chart under the 'Retained Earnings' series.\n10. Ensure `Initialize` includes `AddEquity('JPM')`, fundamental resolution setting, and chart/series setup using `Chart()` and `Series()`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Plotting the Retained Earnings for JPM from its latest balance sheet update.\n* Key setup in `Initialize`: Requesting JPM data/fundamentals, setting up the `Chart` and `Series`.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.BalanceSheet.RetainedEarnings.Value` is used to get the data and `self.Plot()` is used for visualization.\n* Constraints Met: How the plotting occurs upon fundamental data availability (effectively daily when data exists).\n* Supporting Components: The `fine.HasFundamentalData` check and chart initialization.\n* Any assumptions made (plotting the latest reported value daily)."}
{"prompt_id": "FA-E-0055", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'WMT' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for WMT.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the Current Assets value using `fine.FinancialStatements.BalanceSheet.CurrentAssets.Value`.\n7. Log the retrieved value daily using `self.Log()` with the format: 'WMT Current Assets: [Value]'.\n8. Ensure `Initialize` contains `AddEquity('WMT')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Fetching and logging the Current Assets for WMT daily.\n* Key setup in `Initialize`: Requesting WMT data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.BalanceSheet.CurrentAssets.Value` is used.\n* Constraints Met: How daily logging and the specified format are implemented.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made."}
{"prompt_id": "FA-E-0056", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'PG' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for PG.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If fundamental data is available, retrieve the Current Liabilities value using `fine.FinancialStatements.BalanceSheet.CurrentLiabilities.Value`.\n7. Print the retrieved value using `self.Log()` (preferred) or `print()` with the format: 'PG Current Liabilities: [Value]'. This action should occur whenever new fundamental data becomes available (effectively daily check within `OnData`).\n8. Ensure `Initialize` contains `AddEquity('PG')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Printing the Current Liabilities for PG when fundamental data is available.\n* Key setup in `Initialize`: Requesting PG data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental` and the crucial `fine.HasFundamentalData` check triggering the print action.\n* Specific API Usage: How `fine.FinancialStatements.BalanceSheet.CurrentLiabilities.Value` is used.\n* Constraints Met: How the value is printed upon data availability within the `OnData` loop and the specified output format.\n* Supporting Components: The role of `fine.HasFundamentalData` as the trigger.\n* Any assumptions made."}
{"prompt_id": "FA-E-0057", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'UNH' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Declare a class member variable (e.g., `self.latest_common_stock_equity = None`) in `Initialize`.\n4. Implement the `OnData` method.\n5. In `OnData`, access the `FineFundamental` object for UNH.\n6. Check for data availability (`fine.HasFundamentalData`).\n7. If data is available, retrieve the Common Stock Equity value using `fine.FinancialStatements.BalanceSheet.CommonStockEquity.Value`.\n8. Store the retrieved value in the class member variable: `self.latest_common_stock_equity = retrieved_value`.\n9. Optionally, log the update: `self.Log(f'Updated UNH Common Stock Equity: {self.latest_common_stock_equity}')`.\n10. Ensure `Initialize` sets up the equity request, fundamental resolution, and the storage variable.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Retrieving and storing the Common Stock Equity value for UNH daily.\n* Key setup in `Initialize`: Requesting UNH data/fundamentals and initializing the storage variable.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.BalanceSheet.CommonStockEquity.Value` is used.\n* Constraints Met: How the value is stored daily (when available) in the class variable.\n* Supporting Components: The `fine.HasFundamentalData` check and variable initialization.\n* Any assumptions made."}
{"prompt_id": "FA-E-0058", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'AAPL' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. In `Initialize`, create a `Chart` named 'AAPL Balance Sheet'.\n4. In `Initialize`, create a `Series` named 'Total Liabilities Net Minority Interest' for the chart.\n5. Implement the `OnData` method.\n6. In `OnData`, access the `FineFundamental` object for AAPL.\n7. Check for data availability (`fine.HasFundamentalData`).\n8. If data is available, retrieve the Total Liabilities Net Minority Interest value using `fine.FinancialStatements.BalanceSheet.TotalLiabilitiesNetMinorityInterest.Value`.\n9. Use `self.Plot()` inside the `if fine.HasFundamentalData:` block to plot the retrieved value on the specified chart and series upon fundamental data update.\n10. Ensure `Initialize` includes `AddEquity('AAPL')`, fundamental resolution setting, and chart/series setup using `Chart()` and `Series()`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Plotting Total Liabilities Net Minority Interest for AAPL upon fundamental data update.\n* Key setup in `Initialize`: Requesting AAPL data/fundamentals, setting up `Chart` and `Series`.\n* Core Logic in `OnData`: Accessing `FineFundamental`, using `fine.HasFundamentalData` as the trigger.\n* Specific API Usage: How `fine.FinancialStatements.BalanceSheet.TotalLiabilitiesNetMinorityInterest.Value` gets the data and `self.Plot()` visualizes it.\n* Constraints Met: How plotting occurs upon data availability (triggered by `fine.HasFundamentalData`).\n* Supporting Components: The `fine.HasFundamentalData` check and chart setup.\n* Any assumptions made (plotting latest reported value daily when data available)."}
{"prompt_id": "FA-E-0059", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'MSFT' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for MSFT.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, check if the 'Inventories' field exists and has a value (as not all companies have significant inventory). A simple way is to attempt access within a try-except block or check if the value is non-zero/non-null if the property exists.\n7. Retrieve the Inventories value using `fine.FinancialStatements.BalanceSheet.Inventories.Value`.\n8. Log the retrieved value daily *if applicable* using `self.Log()` with the format: 'MSFT Inventories: [Value]'. If inventories are zero or not applicable, log a message indicating that (e.g., 'MSFT Inventories: N/A or 0').\n9. Ensure `Initialize` contains `AddEquity('MSFT')` and sets the fundamental resolution.\n10. Include basic error handling (like a check or note about potential absence of inventory data for some companies).\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Fetching and logging the Inventories value for MSFT daily, considering applicability.\n* Key setup in `Initialize`: Requesting MSFT data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability, and checking for applicability/existence of Inventory data.\n* Specific API Usage: How `fine.FinancialStatements.BalanceSheet.Inventories.Value` is used.\n* Constraints Met: How daily logging (when applicable) and the format are implemented, including handling non-applicable cases.\n* Supporting Components: The `fine.HasFundamentalData` check and the check for inventory applicability.\n* Any assumptions made."}
{"prompt_id": "FA-E-0060", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'GOOG' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for GOOG.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the annual Issuance of Capital Stock using `fine.FinancialStatements.CashFlowStatement.IssuanceOfCapitalStock.TwelveMonths`.\n7. Print the retrieved value daily using `self.Log()` (preferred) or `print()` with the format: 'GOOG Issuance of Capital Stock (Annual/TTM): [Value]'.\n8. Ensure `Initialize` contains `AddEquity('GOOG')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Printing the annual Issuance of Capital Stock for GOOG.\n* Key setup in `Initialize`: Requesting GOOG data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.CashFlowStatement.IssuanceOfCapitalStock.TwelveMonths` is used.\n* Constraints Met: How the annual/TTM value is printed daily and the specific format.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made (using TTM as the latest annual figure available daily)."}
{"prompt_id": "FA-E-0061", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'AMZN' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for AMZN.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the annual Repurchase of Capital Stock using `fine.FinancialStatements.CashFlowStatement.RepurchaseOfCapitalStock.TwelveMonths`.\n7. Log the retrieved value daily using `self.Log()` with the format: 'AMZN Repurchase of Capital Stock (Annual/TTM): [Value]'.\n8. Ensure `Initialize` contains `AddEquity('AMZN')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Logging the annual Repurchase of Capital Stock for AMZN.\n* Key setup in `Initialize`: Requesting AMZN data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.CashFlowStatement.RepurchaseOfCapitalStock.TwelveMonths` is used.\n* Constraints Met: How the annual/TTM value is logged daily and the specific format.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made (using TTM as the latest annual figure available daily)."}
{"prompt_id": "FA-E-0062", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'TSLA' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. In `Initialize`, create a `Chart` named 'TSLA Cash Flow'.\n4. In `Initialize`, create a `Series` named 'Annual Dividend Payments' for the chart.\n5. Implement the `OnData` method.\n6. In `OnData`, access the `FineFundamental` object for TSLA.\n7. Check for data availability (`fine.HasFundamentalData`).\n8. If data is available, retrieve the annual Payment of Cash Dividends using `fine.FinancialStatements.CashFlowStatement.PaymentOfCashDividends.TwelveMonths`. Note: This value might often be zero for TSLA.\n9. Use `self.Plot()` inside the `if fine.HasFundamentalData:` block to plot the retrieved value (even if zero) on the 'TSLA Cash Flow' chart under the 'Annual Dividend Payments' series daily.\n10. Ensure `Initialize` includes `AddEquity('TSLA')`, fundamental resolution setting, and chart/series setup using `Chart()` and `Series()`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Plotting the annual Payment of Cash Dividends for TSLA (if any).\n* Key setup in `Initialize`: Requesting TSLA data/fundamentals, setting up the `Chart` and `Series`.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.CashFlowStatement.PaymentOfCashDividends.TwelveMonths` gets the data and `self.Plot()` visualizes it.\n* Constraints Met: How the annual/TTM value is plotted daily, even if zero.\n* Supporting Components: The `fine.HasFundamentalData` check and chart initialization.\n* Any assumptions made (plotting TTM value daily)."}
{"prompt_id": "FA-E-0063", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'NVDA' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Declare a class member variable (e.g., `self.latest_investing_cash_flow = None`) in `Initialize`.\n4. Implement the `OnData` method.\n5. In `OnData`, access the `FineFundamental` object for NVDA.\n6. Check for data availability (`fine.HasFundamentalData`).\n7. If data is available, retrieve the TTM Investing Cash Flow using `fine.FinancialStatements.CashFlowStatement.InvestingCashFlow.TwelveMonths`.\n8. Store the retrieved value in the class member variable: `self.latest_investing_cash_flow = retrieved_value`.\n9. Optionally, log the update: `self.Log(f'Updated NVDA Investing Cash Flow (TTM): {self.latest_investing_cash_flow}')`.\n10. Ensure `Initialize` sets up the equity request, fundamental resolution, and the storage variable.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Fetching and storing the TTM Investing Cash Flow for NVDA.\n* Key setup in `Initialize`: Requesting NVDA data/fundamentals and initializing the storage variable.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.CashFlowStatement.InvestingCashFlow.TwelveMonths` is used.\n* Constraints Met: How the TTM value is stored upon availability in the class variable.\n* Supporting Components: The `fine.HasFundamentalData` check and variable initialization.\n* Any assumptions made."}
{"prompt_id": "FA-E-0064", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'JNJ' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for JNJ.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the TTM Financing Cash Flow using `fine.FinancialStatements.CashFlowStatement.FinancingCashFlow.TwelveMonths`.\n7. Print the retrieved value daily using `self.Log()` (preferred) with the format: 'JNJ Financing Cash Flow (TTM): [Value]'.\n8. Ensure `Initialize` contains `AddEquity('JNJ')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Printing the TTM Financing Cash Flow for JNJ daily.\n* Key setup in `Initialize`: Requesting JNJ data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.CashFlowStatement.FinancingCashFlow.TwelveMonths` is used.\n* Constraints Met: How the TTM value is printed/logged daily and the specific format.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made."}
{"prompt_id": "FA-E-0065", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'META' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for META.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the Days Sales Outstanding TTM using `fine.OperationRatios.DaysSalesOutstanding.Value`.\n7. Log the retrieved value daily using `self.Log()` with the format: 'META Days Sales Outstanding (TTM): [Value]'.\n8. Ensure `Initialize` contains `AddEquity('META')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Logging the Days Sales Outstanding TTM for META daily.\n* Key setup in `Initialize`: Requesting META data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.OperationRatios.DaysSalesOutstanding.Value` is used.\n* Constraints Met: How daily logging and the specific format are implemented.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made."}
{"prompt_id": "FA-E-0066", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'BRK.B' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. In `Initialize`, create a `Chart` named 'BRK.B Efficiency Ratios'.\n4. In `Initialize`, create a `Series` named 'Days Inventory Outstanding TTM' for the chart.\n5. Implement the `OnData` method.\n6. In `OnData`, access the `FineFundamental` object for BRK.B.\n7. Check for data availability (`fine.HasFundamentalData`).\n8. If data is available, check if Days Inventory Outstanding data is applicable/available (e.g., `fine.OperationRatios.DaysInventoryOutstanding.Value` is not null or some default indicator of absence, as it depends on inventory).\n9. Retrieve the Days Inventory Outstanding TTM using `fine.OperationRatios.DaysInventoryOutstanding.Value`.\n10. Use `self.Plot()` inside the `if fine.HasFundamentalData:` block (and potentially an inner check for applicability) to plot the retrieved value on the specified chart and series daily.\n11. Ensure `Initialize` includes `AddEquity('BRK.B')`, fundamental resolution setting, and chart/series setup using `Chart()` and `Series()`.\n12. Include a note or check regarding the potential non-applicability of DIO for certain companies.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Plotting the Days Inventory Outstanding TTM for BRK.B daily, if applicable.\n* Key setup in `Initialize`: Requesting BRK.B data/fundamentals, setting up `Chart` and `Series`.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability, and checking applicability of DIO.\n* Specific API Usage: How `fine.OperationRatios.DaysInventoryOutstanding.Value` gets the data and `self.Plot()` visualizes it.\n* Constraints Met: How plotting occurs daily when data is available and applicable.\n* Supporting Components: The `fine.HasFundamentalData` check, applicability check, and chart setup.\n* Any assumptions made."}
{"prompt_id": "FA-E-0067", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'V' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for V.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the Days Payables Outstanding TTM using `fine.OperationRatios.DaysPayablesOutstanding.Value`.\n7. Log the retrieved value daily using `self.Log()` with the format: 'V Days Payables Outstanding (TTM): [Value]'.\n8. Ensure `Initialize` contains `AddEquity('V')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Fetching and logging the Days Payables Outstanding TTM for V daily.\n* Key setup in `Initialize`: Requesting V data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.OperationRatios.DaysPayablesOutstanding.Value` is used.\n* Constraints Met: How daily logging and the specific format are implemented.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made."}
{"prompt_id": "FA-E-0068", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'JPM' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for JPM.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the Interest Coverage TTM using `fine.OperationRatios.InterestCoverage.Value`.\n7. Print the retrieved value daily using `self.Log()` (preferred) with the format: 'JPM Interest Coverage (TTM): [Value]'.\n8. Ensure `Initialize` contains `AddEquity('JPM')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Printing the Interest Coverage TTM for JPM daily.\n* Key setup in `Initialize`: Requesting JPM data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.OperationRatios.InterestCoverage.Value` is used.\n* Constraints Met: How the TTM value is printed/logged daily and the specific format.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made."}
{"prompt_id": "FA-E-0069", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'WMT' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Declare a class member variable (e.g., `self.latest_gross_margin = None`) in `Initialize`.\n4. Implement the `OnData` method.\n5. In `OnData`, access the `FineFundamental` object for WMT.\n6. Check for data availability (`fine.HasFundamentalData`).\n7. If data is available, retrieve the latest Gross Margin TTM using `fine.OperationRatios.GrossMargin.Value`.\n8. Store the retrieved value in the class member variable: `self.latest_gross_margin = retrieved_value`.\n9. Optionally, log the update: `self.Log(f'Updated WMT Gross Margin (TTM): {self.latest_gross_margin}')`.\n10. Ensure `Initialize` sets up the equity request, fundamental resolution, and the storage variable.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Retrieving and storing the latest Gross Margin TTM for WMT.\n* Key setup in `Initialize`: Requesting WMT data/fundamentals and initializing the storage variable.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.OperationRatios.GrossMargin.Value` is used.\n* Constraints Met: How the TTM value is stored upon availability in the class variable.\n* Supporting Components: The `fine.HasFundamentalData` check and variable initialization.\n* Any assumptions made."}
{"prompt_id": "FA-E-0070", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'PG' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. In `Initialize`, create a `Chart` named 'PG Income Statement'.\n4. In `Initialize`, create a `Series` named 'Net Income Common (Annual/TTM)' for the chart.\n5. Implement the `OnData` method.\n6. In `OnData`, access the `FineFundamental` object for PG.\n7. Check for data availability (`fine.HasFundamentalData`).\n8. If data is available, retrieve the annual Net Income Applicable To Common Shares using `fine.FinancialStatements.IncomeStatement.NetIncomeApplicableToCommonShares.TwelveMonths`.\n9. Use `self.Plot()` inside the `if fine.HasFundamentalData:` block to plot the retrieved value on the specified chart and series daily.\n10. Ensure `Initialize` includes `AddEquity('PG')`, fundamental resolution setting, and chart/series setup using `Chart()` and `Series()`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Plotting the annual Net Income Applicable To Common Shares for PG.\n* Key setup in `Initialize`: Requesting PG data/fundamentals, setting up `Chart` and `Series`.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.IncomeStatement.NetIncomeApplicableToCommonShares.TwelveMonths` gets the data and `self.Plot()` visualizes it.\n* Constraints Met: How the annual/TTM value is plotted daily.\n* Supporting Components: The `fine.HasFundamentalData` check and chart setup.\n* Any assumptions made (plotting TTM value daily)."}
{"prompt_id": "FA-E-0071", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'MSFT' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for MSFT.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the P/E ratio using `fine.ValuationRatios.PERatio`.\n7. Log the retrieved P/E ratio daily using `self.Log()` with the format: 'MSFT P/E Ratio: [Value]'.\n8. Ensure `Initialize` contains `AddEquity('MSFT')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Retrieving and logging the daily P/E ratio for MSFT.\n* Key setup in `Initialize`: Requesting MSFT data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.ValuationRatios.PERatio` is used.\n* Constraints Met: How daily logging and the specific format are implemented.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made (that PERatio is updated daily based on TTM earnings and current price)."}
{"prompt_id": "FA-E-0072", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN Python algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates (a short period is fine, e.g., 2 days). Set cash.\n2. Request daily resolution data for 'GOOG' using `AddEquity`.\n3. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n4. Implement the `OnData` method.\n5. Use a flag (e.g., `self.market_cap_printed = False`) initialized to `False` in `Initialize` to ensure the value is printed only once.\n6. In `OnData`, check if `self.market_cap_printed` is `False`.\n7. Inside this check, access the `FineFundamental` object for GOOG.\n8. Check if fundamental data is available using `fine.HasFundamentalData`.\n9. If data is available, retrieve the current Market Cap using `fine.MarketCap`.\n10. Print the value using `self.Log()` with the format: 'GOOG Market Cap (Current): [Value]'.\n11. Set the flag `self.market_cap_printed = True` after printing.\n12. Ensure `Initialize` includes `AddEquity('GOOG')`, fundamental resolution setting, and the flag initialization.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Fetching and printing the current Market Cap for GOOG once during initialization/first data arrival.\n* Key setup in `Initialize`: Requesting GOOG data/fundamentals, initializing the `self.market_cap_printed` flag.\n* Core Logic in `OnData`: How the flag is used for single execution, accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.MarketCap` is used.\n* Constraints Met: How the value is printed only once using the flag and the specific log format.\n* Supporting Components: The `fine.HasFundamentalData` check and the boolean flag.\n* Any assumptions made (fundamental data available quickly)."}
{"prompt_id": "FA-E-0073", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate QuantConnect LEAN code that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'AMZN' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. In `Initialize`, create a `Chart` named 'AMZN Income Statement'.\n4. In `Initialize`, create a `Series` named 'Revenue TTM' for the chart.\n5. Implement the `OnData` method.\n6. In `OnData`, access the `FineFundamental` object for AMZN.\n7. Check for data availability (`fine.HasFundamentalData`).\n8. If data is available, retrieve the TTM Revenue using `fine.FinancialStatements.IncomeStatement.TotalRevenue.TwelveMonths`.\n9. Use `self.Plot()` inside the `if fine.HasFundamentalData:` block to plot the retrieved value on the specified chart and series daily.\n10. Ensure `Initialize` includes `AddEquity('AMZN')`, fundamental resolution setting, and chart/series setup using `Chart()` and `Series()`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Plotting the TTM Revenue for AMZN daily.\n* Key setup in `Initialize`: Requesting AMZN data/fundamentals, setting up `Chart` and `Series`.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.IncomeStatement.TotalRevenue.TwelveMonths` gets the data and `self.Plot()` visualizes it.\n* Constraints Met: How the TTM value is plotted daily.\n* Supporting Components: The `fine.HasFundamentalData` check and chart initialization.\n* Any assumptions made."}
{"prompt_id": "FA-E-0074", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN script that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'TSLA' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for TSLA.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the Debt/Equity Ratio using `fine.ValuationRatios.DebtEquityRatio`.\n7. Log the retrieved Debt/Equity Ratio daily using `self.Log()` with the format: 'TSLA DebtEquityRatio: [Value]'.\n8. Add a conditional check: If the retrieved `DebtEquityRatio` is greater than 2.0, generate a warning message using `self.Log()` or `self.Debug()` with the format: 'WARNING: TSLA DebtEquityRatio ([Value]) exceeds 2.0'.\n9. Ensure `Initialize` contains `AddEquity('TSLA')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Logging TSLA's DebtEquityRatio daily and warning if it exceeds 2.0.\n* Key setup in `Initialize`: Requesting TSLA data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability, retrieving the ratio, and the conditional check ( > 2.0 ).\n* Specific API Usage: How `fine.ValuationRatios.DebtEquityRatio` is used and how `self.Log()` is used for both regular logging and warnings.\n* Constraints Met: How daily logging, the specific format, and the conditional warning based on the 2.0 threshold are implemented.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made."}
{"prompt_id": "FA-E-0075", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'NVDA' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Declare a class member variable (e.g., `self.latest_dividend_yield = None`) in `Initialize`.\n4. Implement the `OnData` method.\n5. In `OnData`, access the `FineFundamental` object for NVDA.\n6. Check for data availability (`fine.HasFundamentalData`).\n7. If data is available, retrieve the Dividend Yield using `fine.ValuationRatios.DividendYield`.\n8. Store the retrieved value in the class member variable: `self.latest_dividend_yield = retrieved_value`.\n9. Optionally, log the update: `self.Log(f'Updated NVDA DividendYield: {self.latest_dividend_yield}')`.\n10. Ensure `Initialize` sets up the equity request, fundamental resolution, and the storage variable.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Getting and storing the Dividend Yield for NVDA daily.\n* Key setup in `Initialize`: Requesting NVDA data/fundamentals and initializing the storage variable.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.ValuationRatios.DividendYield` is used.\n* Constraints Met: How the value is stored daily (when available) in the class variable.\n* Supporting Components: The `fine.HasFundamentalData` check and variable initialization.\n* Any assumptions made (DividendYield reflects current yield based on latest price and TTM dividends)."}
{"prompt_id": "FA-E-0076", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'JNJ' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for JNJ.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the Price-to-Book (P/B) Ratio using `fine.ValuationRatios.PBRatio`.\n7. Log the retrieved P/B Ratio daily using `self.Log()` with the format: 'JNJ PBRatio: [Value]'.\n8. Ensure `Initialize` contains `AddEquity('JNJ')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Logging the P/B Ratio for JNJ daily.\n* Key setup in `Initialize`: Requesting JNJ data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.ValuationRatios.PBRatio` is used.\n* Constraints Met: How daily logging and the specific format are implemented.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made."}
{"prompt_id": "FA-E-0077", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'META' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. In `Initialize`, create a `Chart` named 'META Income Statement'.\n4. In `Initialize`, create a `Series` named 'Net Income TTM' for the chart.\n5. Implement the `OnData` method.\n6. In `OnData`, access the `FineFundamental` object for META.\n7. Check for data availability (`fine.HasFundamentalData`).\n8. If data is available, retrieve the TTM Net Income (using NetIncomeApplicableToCommonShares as a common proxy) via `fine.FinancialStatements.IncomeStatement.NetIncome.TwelveMonths` or `fine.FinancialStatements.IncomeStatement.NetIncomeApplicableToCommonShares.TwelveMonths`.\n9. Use `self.Plot()` inside the `if fine.HasFundamentalData:` block to plot the retrieved value on the specified chart and series daily.\n10. Ensure `Initialize` includes `AddEquity('META')`, fundamental resolution setting, and chart/series setup using `Chart()` and `Series()`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Plotting the TTM Net Income for META.\n* Key setup in `Initialize`: Requesting META data/fundamentals, setting up `Chart` and `Series`.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How the chosen Net Income TTM field (e.g., `NetIncome.TwelveMonths`) is accessed and `self.Plot()` is used.\n* Constraints Met: How the TTM value is plotted daily.\n* Supporting Components: The `fine.HasFundamentalData` check and chart initialization.\n* Any assumptions made (e.g., which Net Income field is used)."}
{"prompt_id": "FA-E-0078", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate QuantConnect LEAN code that performs the following steps:\n1. Initialize the algorithm: Set start/end dates (a short period is fine). Set cash.\n2. Request daily resolution data for 'BRK.B' using `AddEquity`.\n3. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n4. Implement the `OnData` method.\n5. Use a flag (e.g., `self.sector_printed = False`) initialized to `False` in `Initialize`.\n6. In `OnData`, check if `self.sector_printed` is `False`.\n7. Inside this check, access the `FineFundamental` object for BRK.B.\n8. Check if fundamental data is available using `fine.HasFundamentalData`.\n9. If data is available, retrieve the Sector Name using `fine.CompanyReference.SectorName`.\n10. Print the Sector Name using `self.Log()` with the format: 'BRK.B Sector Name: [Name]'.\n11. Set the flag `self.sector_printed = True`.\n12. Ensure `Initialize` includes `AddEquity('BRK.B')`, fundamental resolution setting, and flag initialization.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Printing the Sector Name for BRK.B once upon initialization/first data.\n* Key setup in `Initialize`: Requesting BRK.B data/fundamentals, initializing the flag.\n* Core Logic in `OnData`: Using the flag for single execution, accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.CompanyReference.SectorName` is used.\n* Constraints Met: How the value is printed only once using the flag and the specific log format.\n* Supporting Components: The `fine.HasFundamentalData` check and the boolean flag.\n* Any assumptions made."}
{"prompt_id": "FA-E-0079", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN script that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'V' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for V.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the Return on Equity (ROE) TTM using `fine.OperationRatios.ROE.Value`.\n7. Log the retrieved ROE TTM daily using `self.Log()` with the format: 'V ROE (TTM): [Value]'.\n8. Ensure `Initialize` contains `AddEquity('V')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Logging the ROE TTM for V daily.\n* Key setup in `Initialize`: Requesting V data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.OperationRatios.ROE.Value` is used.\n* Constraints Met: How daily logging and the specific format are implemented.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made."}
{"prompt_id": "FA-E-0080", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'JPM' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. In `Initialize`, create a `Chart` named 'JPM Liquidity Ratios'.\n4. In `Initialize`, create a `Series` named 'Quick Ratio' for the chart.\n5. Implement the `OnData` method.\n6. In `OnData`, access the `FineFundamental` object for JPM.\n7. Check for data availability (`fine.HasFundamentalData`).\n8. If data is available, retrieve the Quick Ratio using `fine.OperationRatios.QuickRatio.Value`.\n9. Use `self.Plot()` inside the `if fine.HasFundamentalData:` block to plot the retrieved value on the specified chart and series daily.\n10. Ensure `Initialize` includes `AddEquity('JPM')`, fundamental resolution setting, and chart/series setup using `Chart()` and `Series()`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Plotting the Quick Ratio for JPM daily.\n* Key setup in `Initialize`: Requesting JPM data/fundamentals, setting up `Chart` and `Series`.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.OperationRatios.QuickRatio.Value` gets the data and `self.Plot()` visualizes it.\n* Constraints Met: How the Quick Ratio is plotted daily.\n* Supporting Components: The `fine.HasFundamentalData` check and chart initialization.\n* Any assumptions made."}
{"prompt_id": "FA-E-0081", "strategy_category": "Fundamental Analysis", "prompt_text": "Write QuantConnect LEAN code that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'WMT' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for WMT.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the Earnings Per Share (EPS) TTM using `fine.EarningReports.BasicEPS.TwelveMonths` (or `DilutedEPS` if preferred).\n7. Log the retrieved EPS TTM daily using `self.Log()` with the format: 'WMT EPS (TTM): [Value]'.\n8. Ensure `Initialize` contains `AddEquity('WMT')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Logging the EPS TTM for WMT daily.\n* Key setup in `Initialize`: Requesting WMT data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.EarningReports.BasicEPS.TwelveMonths` (or similar) is used.\n* Constraints Met: How daily logging and the specific format are implemented.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made (e.g., using Basic EPS)."}
{"prompt_id": "FA-E-0082", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script that performs the following steps:\n1. Initialize the algorithm: Set start/end dates (a short period is fine). Set cash.\n2. Request daily resolution data for 'PG' using `AddEquity`.\n3. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n4. Implement the `OnData` method.\n5. Use a flag (e.g., `self.assets_printed = False`) initialized to `False` in `Initialize`.\n6. In `OnData`, check if `self.assets_printed` is `False`.\n7. Inside this check, access the `FineFundamental` object for PG.\n8. Check if fundamental data is available using `fine.HasFundamentalData`.\n9. If data is available, retrieve the Total Assets value from the latest balance sheet using `fine.FinancialStatements.BalanceSheet.TotalAssets.Value`.\n10. Print the value using `self.Log()` with the format: 'PG Total Assets (Latest): [Value]'.\n11. Set the flag `self.assets_printed = True`.\n12. Ensure `Initialize` includes `AddEquity('PG')`, fundamental resolution setting, and flag initialization.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Printing the latest Total Assets value for PG once during initialization/first data arrival.\n* Key setup in `Initialize`: Requesting PG data/fundamentals, initializing the flag.\n* Core Logic in `OnData`: Using the flag for single execution, accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.BalanceSheet.TotalAssets.Value` is used.\n* Constraints Met: How the value is printed only once using the flag and the specific log format.\n* Supporting Components: The `fine.HasFundamentalData` check and the boolean flag.\n* Any assumptions made."}
{"prompt_id": "FA-E-0083", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'UNH' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. In `Initialize`, create a `Chart` named 'UNH Profitability Ratios'.\n4. In `Initialize`, create a `Series` named 'Operating Margin TTM' for the chart.\n5. Implement the `OnData` method.\n6. In `OnData`, access the `FineFundamental` object for UNH.\n7. Check for data availability (`fine.HasFundamentalData`).\n8. If data is available, retrieve the Operating Margin TTM using `fine.OperationRatios.OperatingMargin.Value`.\n9. Use `self.Plot()` inside the `if fine.HasFundamentalData:` block to plot the retrieved value on the specified chart and series daily.\n10. Ensure `Initialize` includes `AddEquity('UNH')`, fundamental resolution setting, and chart/series setup using `Chart()` and `Series()`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Plotting the Operating Margin TTM for UNH daily.\n* Key setup in `Initialize`: Requesting UNH data/fundamentals, setting up `Chart` and `Series`.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.OperationRatios.OperatingMargin.Value` gets the data and `self.Plot()` visualizes it.\n* Constraints Met: How the TTM Operating Margin is plotted daily.\n* Supporting Components: The `fine.HasFundamentalData` check and chart initialization.\n* Any assumptions made."}
{"prompt_id": "FA-E-0084", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'AAPL' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for AAPL.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the Price-to-Sales (P/S) Ratio using `fine.ValuationRatios.PSRatio`.\n7. Log the retrieved P/S Ratio daily using `self.Log()` with the format: 'AAPL PSRatio: [Value]'.\n8. Ensure `Initialize` contains `AddEquity('AAPL')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Logging the P/S Ratio for AAPL daily.\n* Key setup in `Initialize`: Requesting AAPL data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.ValuationRatios.PSRatio` is used.\n* Constraints Met: How daily logging and the specific format are implemented.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made."}
{"prompt_id": "FA-E-0085", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates (a short period is fine). Set cash.\n2. Request daily resolution data for 'MSFT' using `AddEquity`.\n3. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n4. Implement the `OnData` method.\n5. Use a flag (e.g., `self.industry_printed = False`) initialized to `False` in `Initialize`.\n6. In `OnData`, check if `self.industry_printed` is `False`.\n7. Inside this check, access the `FineFundamental` object for MSFT.\n8. Check if fundamental data is available using `fine.HasFundamentalData`.\n9. If data is available, retrieve the Industry Name using `fine.CompanyReference.IndustryName`.\n10. Print the Industry Name using `self.Log()` with the format: 'MSFT Industry Name: [Name]'.\n11. Set the flag `self.industry_printed = True`.\n12. Ensure `Initialize` includes `AddEquity('MSFT')`, fundamental resolution setting, and flag initialization.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Printing the Industry Name for MSFT once upon initialization/first data.\n* Key setup in `Initialize`: Requesting MSFT data/fundamentals, initializing the flag.\n* Core Logic in `OnData`: Using the flag for single execution, accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.CompanyReference.IndustryName` is used.\n* Constraints Met: How the value is printed only once using the flag and the specific log format.\n* Supporting Components: The `fine.HasFundamentalData` check and the boolean flag.\n* Any assumptions made."}
{"prompt_id": "FA-E-0086", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'GOOG' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for GOOG.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the TTM Free Cash Flow using `fine.FinancialStatements.CashFlowStatement.FreeCashFlow.TwelveMonths`.\n7. Log the retrieved TTM Free Cash Flow daily using `self.Log()` with the format: 'GOOG FreeCashFlow (TTM): [Value]'.\n8. Ensure `Initialize` contains `AddEquity('GOOG')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Logging the TTM Free Cash Flow for GOOG daily.\n* Key setup in `Initialize`: Requesting GOOG data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.CashFlowStatement.FreeCashFlow.TwelveMonths` is used.\n* Constraints Met: How daily logging and the specific format are implemented.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made."}
{"prompt_id": "FA-E-0087", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'AMZN' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. In `Initialize`, create a `Chart` named 'AMZN Liquidity Ratios'.\n4. In `Initialize`, create a `Series` named 'Current Ratio' for the chart.\n5. Implement the `OnData` method.\n6. In `OnData`, access the `FineFundamental` object for AMZN.\n7. Check for data availability (`fine.HasFundamentalData`).\n8. If data is available, retrieve the Current Ratio using `fine.OperationRatios.CurrentRatio.Value`.\n9. Use `self.Plot()` inside the `if fine.HasFundamentalData:` block to plot the retrieved value on the specified chart and series daily.\n10. Ensure `Initialize` includes `AddEquity('AMZN')`, fundamental resolution setting, and chart/series setup using `Chart()` and `Series()`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Plotting the Current Ratio for AMZN daily.\n* Key setup in `Initialize`: Requesting AMZN data/fundamentals, setting up `Chart` and `Series`.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.OperationRatios.CurrentRatio.Value` gets the data and `self.Plot()` visualizes it.\n* Constraints Met: How the Current Ratio is plotted daily.\n* Supporting Components: The `fine.HasFundamentalData` check and chart initialization.\n* Any assumptions made."}
{"prompt_id": "FA-E-0088", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'TSLA' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for TSLA.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the Book Value Per Share using `fine.ValuationRatios.BookValuePerShare`.\n7. Log the retrieved Book Value Per Share daily using `self.Log()` with the format: 'TSLA BookValuePerShare: [Value]'.\n8. Ensure `Initialize` contains `AddEquity('TSLA')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Logging the Book Value Per Share for TSLA daily.\n* Key setup in `Initialize`: Requesting TSLA data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.ValuationRatios.BookValuePerShare` is used.\n* Constraints Met: How daily logging and the specific format are implemented.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made."}
{"prompt_id": "FA-E-0089", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'NVDA' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Declare a class member variable (e.g., `self.latest_beta = None`) in `Initialize`.\n4. Implement the `OnData` method.\n5. In `OnData`, access the `FineFundamental` object for NVDA.\n6. Check for data availability (`fine.HasFundamentalData`).\n7. If data is available, retrieve the Beta value using `fine.OperationRatios.Beta.Value`.\n8. Store the retrieved value in the class member variable: `self.latest_beta = retrieved_value`.\n9. Optionally, log the update: `self.Log(f'Updated NVDA Beta: {self.latest_beta}')`.\n10. Ensure `Initialize` sets up the equity request, fundamental resolution, and the storage variable.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Storing the Beta for NVDA daily.\n* Key setup in `Initialize`: Requesting NVDA data/fundamentals and initializing the storage variable.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.OperationRatios.Beta.Value` is used.\n* Constraints Met: How the value is stored daily (when available) in the class variable.\n* Supporting Components: The `fine.HasFundamentalData` check and variable initialization.\n* Any assumptions made."}
{"prompt_id": "FA-E-0090", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script that performs the following steps:\n1. Initialize the algorithm: Set start/end dates (a short period is fine). Set cash.\n2. Request daily resolution data for 'JNJ' using `AddEquity`.\n3. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n4. Implement the `OnData` method.\n5. Use a flag (e.g., `self.op_cash_flow_printed = False`) initialized to `False` in `Initialize`.\n6. In `OnData`, check if `self.op_cash_flow_printed` is `False`.\n7. Inside this check, access the `FineFundamental` object for JNJ.\n8. Check if fundamental data is available using `fine.HasFundamentalData`.\n9. If data is available, retrieve the TTM Operating Cash Flow using `fine.FinancialStatements.CashFlowStatement.OperatingCashFlow.TwelveMonths`.\n10. Print the value using `self.Log()` with the format: 'JNJ Operating Cash Flow (TTM): [Value]'.\n11. Set the flag `self.op_cash_flow_printed = True`.\n12. Ensure `Initialize` includes `AddEquity('JNJ')`, fundamental resolution setting, and flag initialization.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Printing the TTM Operating Cash Flow for JNJ once upon initialization/first data.\n* Key setup in `Initialize`: Requesting JNJ data/fundamentals, initializing the flag.\n* Core Logic in `OnData`: Using the flag for single execution, accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.CashFlowStatement.OperatingCashFlow.TwelveMonths` is used.\n* Constraints Met: How the value is printed only once using the flag and the specific log format.\n* Supporting Components: The `fine.HasFundamentalData` check and the boolean flag.\n* Any assumptions made."}
{"prompt_id": "FA-E-0091", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'META' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for META.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the Return on Assets (ROA) TTM using `fine.OperationRatios.ROA.Value`.\n7. Log the retrieved ROA TTM daily using `self.Log()` with the format: 'META ROA (TTM): [Value]'.\n8. Ensure `Initialize` contains `AddEquity('META')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Logging the ROA TTM for META daily.\n* Key setup in `Initialize`: Requesting META data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.OperationRatios.ROA.Value` is used.\n* Constraints Met: How daily logging and the specific format are implemented.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made."}
{"prompt_id": "FA-E-0092", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'BRK.B' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. In `Initialize`, create a `Chart` named 'BRK.B Income Statement'.\n4. In `Initialize`, create a `Series` named 'Gross Profit (Annual/TTM)' for the chart.\n5. Implement the `OnData` method.\n6. In `OnData`, access the `FineFundamental` object for BRK.B.\n7. Check for data availability (`fine.HasFundamentalData`).\n8. If data is available, retrieve the annual Gross Profit using `fine.FinancialStatements.IncomeStatement.GrossProfit.TwelveMonths`.\n9. Use `self.Plot()` inside the `if fine.HasFundamentalData:` block to plot the retrieved value on the specified chart and series daily.\n10. Ensure `Initialize` includes `AddEquity('BRK.B')`, fundamental resolution setting, and chart/series setup using `Chart()` and `Series()`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Plotting the annual Gross Profit for BRK.B.\n* Key setup in `Initialize`: Requesting BRK.B data/fundamentals, setting up `Chart` and `Series`.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.IncomeStatement.GrossProfit.TwelveMonths` gets the data and `self.Plot()` visualizes it.\n* Constraints Met: How the annual/TTM value is plotted daily.\n* Supporting Components: The `fine.HasFundamentalData` check and chart initialization.\n* Any assumptions made (plotting TTM value daily)."}
{"prompt_id": "FA-E-0093", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'V' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for V.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the Shares Outstanding using `fine.CompanyReference.SharesOutstanding`.\n7. Log the retrieved Shares Outstanding daily using `self.Log()` with the format: 'V Shares Outstanding: [Value]'.\n8. Ensure `Initialize` contains `AddEquity('V')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Logging the Shares Outstanding for V daily.\n* Key setup in `Initialize`: Requesting V data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.CompanyReference.SharesOutstanding` is used.\n* Constraints Met: How daily logging and the specific format are implemented.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made (that SharesOutstanding is updated based on latest filings/price adjustments)."}
{"prompt_id": "FA-E-0094", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script that performs the following steps:\n1. Initialize the algorithm: Set start/end dates (a short period is fine). Set cash.\n2. Request daily resolution data for 'JPM' using `AddEquity`.\n3. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n4. Implement the `OnData` method.\n5. Use a flag (e.g., `self.cik_printed = False`) initialized to `False` in `Initialize`.\n6. In `OnData`, check if `self.cik_printed` is `False`.\n7. Inside this check, access the `FineFundamental` object for JPM.\n8. Check if fundamental data is available using `fine.HasFundamentalData`.\n9. If data is available, retrieve the CIK identifier using `fine.CompanyReference.CIK`.\n10. Print the CIK using `self.Log()` with the format: 'JPM CIK: [Value]'.\n11. Set the flag `self.cik_printed = True`.\n12. Ensure `Initialize` includes `AddEquity('JPM')`, fundamental resolution setting, and flag initialization.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Printing the CIK for JPM once upon initialization/first data.\n* Key setup in `Initialize`: Requesting JPM data/fundamentals, initializing the flag.\n* Core Logic in `OnData`: Using the flag for single execution, accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.CompanyReference.CIK` is used.\n* Constraints Met: How the value is printed only once using the flag and the specific log format.\n* Supporting Components: The `fine.HasFundamentalData` check and the boolean flag.\n* Any assumptions made."}
{"prompt_id": "FA-E-0095", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'WMT' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. In `Initialize`, create a `Chart` named 'WMT Dividend Ratios'.\n4. In `Initialize`, create a `Series` named 'Payout Ratio' for the chart.\n5. Implement the `OnData` method.\n6. In `OnData`, access the `FineFundamental` object for WMT.\n7. Check for data availability (`fine.HasFundamentalData`).\n8. If data is available, retrieve the Payout Ratio using `fine.ValuationRatios.PayoutRatio`.\n9. Use `self.Plot()` inside the `if fine.HasFundamentalData:` block to plot the retrieved value on the specified chart and series daily.\n10. Ensure `Initialize` includes `AddEquity('WMT')`, fundamental resolution setting, and chart/series setup using `Chart()` and `Series()`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Plotting the Payout Ratio for WMT daily.\n* Key setup in `Initialize`: Requesting WMT data/fundamentals, setting up `Chart` and `Series`.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.ValuationRatios.PayoutRatio` gets the data and `self.Plot()` visualizes it.\n* Constraints Met: How the Payout Ratio is plotted daily.\n* Supporting Components: The `fine.HasFundamentalData` check and chart initialization.\n* Any assumptions made."}
{"prompt_id": "FA-E-0096", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'PG' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for PG.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the Sales Per Share TTM using `fine.ValuationRatios.SalesPerShare`.\n7. Log the retrieved Sales Per Share TTM daily using `self.Log()` with the format: 'PG SalesPerShare (TTM): [Value]'.\n8. Ensure `Initialize` contains `AddEquity('PG')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Logging the Sales Per Share TTM for PG daily.\n* Key setup in `Initialize`: Requesting PG data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.ValuationRatios.SalesPerShare` is used.\n* Constraints Met: How daily logging and the specific format are implemented.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made."}
{"prompt_id": "FA-E-0097", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'UNH' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Declare a class member variable (e.g., `self.latest_total_liabilities = None`) in `Initialize`.\n4. Implement the `OnData` method.\n5. In `OnData`, access the `FineFundamental` object for UNH.\n6. Check for data availability (`fine.HasFundamentalData`).\n7. If data is available, retrieve the annual Total Liabilities value using `fine.FinancialStatements.BalanceSheet.TotalLiabilities.Value` (accessing the latest reported annual/quarterly figure).\n8. Store the retrieved value in the class member variable: `self.latest_total_liabilities = retrieved_value`.\n9. Optionally, log the update: `self.Log(f'Updated UNH Total Liabilities: {self.latest_total_liabilities}')`.\n10. Ensure `Initialize` sets up the equity request, fundamental resolution, and the storage variable.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Storing the annual Total Liabilities for UNH.\n* Key setup in `Initialize`: Requesting UNH data/fundamentals and initializing the storage variable.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.BalanceSheet.TotalLiabilities.Value` is used.\n* Constraints Met: How the value is stored upon availability in the class variable.\n* Supporting Components: The `fine.HasFundamentalData` check and variable initialization.\n* Any assumptions made (using `.Value` to get the latest reported figure)."}
{"prompt_id": "FA-E-0098", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'AAPL' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for AAPL.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the PEG Ratio using `fine.ValuationRatios.PEGRatio`.\n7. Print the retrieved PEG Ratio daily using `self.Log()` (preferred) with the format: 'AAPL PEGRatio: [Value]'. Handle potential cases where PEGRatio might not be calculated (e.g., negative earnings growth) by checking if the value is valid before logging, or logging 'N/A'.\n8. Ensure `Initialize` contains `AddEquity('AAPL')` and sets the fundamental resolution.\n9. Include error handling or checking for PEGRatio validity.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Printing the PEG Ratio for AAPL daily.\n* Key setup in `Initialize`: Requesting AAPL data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability, retrieving PEGRatio.\n* Specific API Usage: How `fine.ValuationRatios.PEGRatio` is used.\n* Constraints Met: How daily printing/logging and the specific format are implemented, including handling invalid/unavailable PEG values.\n* Supporting Components: The `fine.HasFundamentalData` check and the validity check for PEGRatio.\n* Any assumptions made."}
{"prompt_id": "FA-E-0099", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'MSFT' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. Implement the `OnData` method.\n4. In `OnData`, access the `FineFundamental` object for MSFT.\n5. Check for data availability (`fine.HasFundamentalData`).\n6. If data is available, retrieve the Asset Turnover TTM using `fine.OperationRatios.AssetTurnover.Value`.\n7. Log the retrieved Asset Turnover TTM daily using `self.Log()` with the format: 'MSFT Asset Turnover (TTM): [Value]'.\n8. Ensure `Initialize` contains `AddEquity('MSFT')` and sets the fundamental resolution.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Logging the Asset Turnover TTM for MSFT daily.\n* Key setup in `Initialize`: Requesting MSFT data and fundamentals.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.OperationRatios.AssetTurnover.Value` is used.\n* Constraints Met: How daily logging and the specific format are implemented.\n* Supporting Components: The `fine.HasFundamentalData` check.\n* Any assumptions made."}
{"prompt_id": "FA-E-0100", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code that performs the following steps:\n1. Initialize the algorithm: Set start/end dates, cash. Add 'GOOG' equity using `AddEquity`.\n2. Request fundamental data by setting `self.UniverseSettings.Resolution = Resolution.Daily`.\n3. In `Initialize`, create a `Chart` named 'GOOG Income Statement Metrics'.\n4. In `Initialize`, create a `Series` named 'EBITDA TTM' for the chart.\n5. Implement the `OnData` method.\n6. In `OnData`, access the `FineFundamental` object for GOOG.\n7. Check for data availability (`fine.HasFundamentalData`).\n8. If data is available, retrieve the TTM EBITDA using `fine.FinancialStatements.IncomeStatement.EBITDA.TwelveMonths`.\n9. Use `self.Plot()` inside the `if fine.HasFundamentalData:` block to plot the retrieved value on the specified chart and series daily.\n10. Ensure `Initialize` includes `AddEquity('GOOG')`, fundamental resolution setting, and chart/series setup using `Chart()` and `Series()`.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose: Plotting the TTM EBITDA for GOOG.\n* Key setup in `Initialize`: Requesting GOOG data/fundamentals, setting up `Chart` and `Series`.\n* Core Logic in `OnData`: Accessing `FineFundamental`, checking data availability.\n* Specific API Usage: How `fine.FinancialStatements.IncomeStatement.EBITDA.TwelveMonths` gets the data and `self.Plot()` visualizes it.\n* Constraints Met: How the TTM value is plotted daily.\n* Supporting Components: The `fine.HasFundamentalData` check and chart initialization.\n* Any assumptions made."}
{"prompt_id": "FA-E-0101", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm in Python that retrieves and logs the daily Net Margin TTM for Amazon (AMZN).\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range (e.g., 2023 using `SetStartDate`/`SetEndDate`).\n2. Add AMZN equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for AMZN (e.g., via `UniverseSettings` or `security.SetFundamentalsRequired(True)`).\n4. Schedule an event function (`log_net_margin`) to run daily, 30 minutes after market open for AMZN.\n5. In `log_net_margin`, get the AMZN `Security` object.\n6. Check if the `Security` object and its `Fundamentals` property are available.\n7. Access the Net Margin (`OperationRatios.NetMargin`) from the `Fundamentals` data.\n8. Check if the retrieved Net Margin value is valid (not None).\n9. If valid, log the value using `self.Log`. If invalid or unavailable, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"AMZN\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"AMZN\"), self.TimeRules.AfterMarketOpen(\"AMZN\", 30), self.log_net_margin)` for daily execution.\n- Must access the metric via `security.Fundamentals.OperationRatios.NetMargin`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only AMZN.\n- Logging must occur precisely 30 minutes after AMZN's market open each trading day.\n- Log output format for available metric: \"AMZN NetMargin TTM: [value]\"\n- Log output format for unavailable metric: \"AMZN NetMargin TTM: N/A\"\n- Backtest period should be explicitly set (e.g., 2023).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_net_margin`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before logging.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging AMZN's daily TTM Net Margin).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, scheduling the `log_net_margin` event).\n* How the `Schedule.On` function with `AfterMarketOpen` rule triggers the daily logging.\n* The specific API property used (`Fundamentals.OperationRatios.NetMargin`).\n* How the algorithm checks for data availability before accessing the metric.\n* How the algorithm handles unavailable data by logging 'N/A'.\n* The exact format of the log output for both available and unavailable cases."}
{"prompt_id": "FA-E-0102", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to fetch and print the Country ID for Tesla (TSLA) during initialization.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a start date (e.g., using `SetStartDate`).\n2. Add TSLA equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for TSLA.\n4. Immediately after adding the equity, retrieve the TSLA `Security` object.\n5. Check if the `Security` object and its `Fundamentals` property are available.\n6. Access the Country ID (`CompanyReference.CountryId`) from the `Fundamentals` data.\n7. Check if the retrieved ID is valid (not None or empty).\n8. If valid, print the ID using `self.Log` (or `self.Debug`). If invalid or unavailable, print 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"TSLA\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must access the metric via `self.Securities[\"TSLA\"].Fundamentals.CompanyReference.CountryId` *within `Initialize`*.\n- Must use `self.Log()` or `self.Debug()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only TSLA.\n- Fetching and printing must occur *only once* during the `Initialize` phase.\n- Print output format for available ID: \"TSLA CountryId: [value]\"\n- Print output format for unavailable ID: \"TSLA CountryId: N/A\"\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date, data request, enabling fundamentals, retrieval logic).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks immediately after `AddEquity` for data availability (`security`, `security.Fundamentals`) before accessing the metric.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (printing TSLA's Country ID at initialization).\n* Key setup steps in `Initialize` (date, adding equity, enabling fundamental data).\n* Why the retrieval happens within `Initialize`.\n* The specific API property used (`Fundamentals.CompanyReference.CountryId`).\n* How the algorithm checks for the availability of the Security object and its fundamental data.\n* How the algorithm handles unavailable data by printing 'N/A'.\n* The exact format of the print output for both available and unavailable cases."}
{"prompt_id": "FA-E-0103", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to plot the Cash Return for Nvidia (NVDA) daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range (e.g., 2023 using `SetStartDate`/`SetEndDate`).\n2. Add NVDA equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for NVDA.\n4. Create a `Chart` named 'NVDA Fundamentals' and register a `Series` named 'Cash Return'.\n5. Schedule an event function (`plot_cash_return`) to run daily, at market close for NVDA.\n6. In `plot_cash_return`, get the NVDA `Security` object.\n7. Check if the `Security` object and its `Fundamentals` property are available.\n8. Access the Cash Return (`OperationRatios.CashReturn`) from the `Fundamentals` data.\n9. Check if the retrieved value is valid (not None).\n10. If valid, plot the value using `self.Plot` on the specified chart and series.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"NVDA\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `Chart('NVDA Fundamentals')` and `Series('Cash Return', SeriesType.Line, ...)` for plot setup in `Initialize`.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"NVDA\"), self.TimeRules.AtMarketClose(\"NVDA\"), self.plot_cash_return)` for daily execution.\n- Must access the metric via `security.Fundamentals.OperationRatios.CashReturn`.\n- Must use `self.Plot('NVDA Fundamentals', 'Cash Return', value)` to plot.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only NVDA.\n- Plotting must occur exactly once per trading day, at NVDA's market close.\n- The plot must be named exactly 'NVDA Fundamentals'.\n- The series must be named exactly 'Cash Return'.\n- Only plot valid metric values (must check for None).\n- Backtest period should be explicitly set (e.g., 2023).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, plot creation, scheduling).\n- Implement the scheduled event handler method (`plot_cash_return`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before plotting.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (plotting NVDA's daily Cash Return).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, creating chart/series, scheduling the `plot_cash_return` event).\n* How the `Schedule.On` function with `AtMarketClose` rule triggers the daily plotting.\n* The specific API property used (`Fundamentals.OperationRatios.CashReturn`).\n* How `self.Plot` is used with the specified chart and series names.\n* How the algorithm checks for data availability before accessing and plotting the metric.\n* Any assumptions made (e.g., `CashReturn` represents the desired period like TTM)." }
{"prompt_id": "FA-E-0104", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to log the Earnings Yield for Johnson & Johnson (JNJ) daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range (e.g., 2023 using `SetStartDate`/`SetEndDate`).\n2. Add JNJ equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for JNJ.\n4. Schedule an event function (`log_earnings_yield`) to run daily, 30 minutes after market open for JNJ.\n5. In `log_earnings_yield`, get the JNJ `Security` object.\n6. Check if the `Security` object and its `Fundamentals` property are available.\n7. Access the Earnings Yield (`ValuationRatios.EarningsYield`) from the `Fundamentals` data.\n8. Check if the retrieved value is valid (not None).\n9. If valid, log the value using `self.Log`. If invalid or unavailable, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"JNJ\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"JNJ\"), self.TimeRules.AfterMarketOpen(\"JNJ\", 30), self.log_earnings_yield)` for daily execution.\n- Must access the metric via `security.Fundamentals.ValuationRatios.EarningsYield`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only JNJ.\n- Logging must occur precisely 30 minutes after JNJ's market open each trading day.\n- Log output format for available metric: \"JNJ EarningsYield: [value]\"\n- Log output format for unavailable metric: \"JNJ EarningsYield: N/A\"\n- Backtest period should be explicitly set (e.g., 2023).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_earnings_yield`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before logging.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging JNJ's daily Earnings Yield).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, scheduling the `log_earnings_yield` event).\n* How the `Schedule.On` function with `AfterMarketOpen` rule triggers the daily logging.\n* The specific API property used (`Fundamentals.ValuationRatios.EarningsYield`).\n* How the algorithm checks for data availability before accessing the metric.\n* How the algorithm handles unavailable data by logging 'N/A'.\n* The exact format of the log output for both available and unavailable cases."}
{"prompt_id": "FA-E-0105", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to retrieve and store the annual Research And Development expense for Meta Platforms (META) daily, logging the stored value.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range covering at least two fiscal years (e.g., 2022-2023 using `SetStartDate`/`SetEndDate`).\n2. Add META equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for META.\n4. Declare a class member variable `self.meta_annual_rnd` initialized to `None`.\n5. Schedule an event function (`update_annual_rnd`) to run daily, at market open for META.\n6. In `update_annual_rnd`, get the META `Security` object.\n7. Check if the `Security` object and its `Fundamentals` property are available.\n8. Access the annual R&D expense (`FinancialStatements.IncomeStatement.ResearchAndDevelopment.OneYear`) from `Fundamentals`.\n9. Check if the retrieved value is valid (not None).\n10. If valid, update `self.meta_annual_rnd` with the value and log the *newly stored* value.\n11. If invalid or unavailable, log that the value was not updated/available.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"META\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"META\"), self.TimeRules.AtMarketOpen(\"META\"), self.update_annual_rnd)`.\n- Must access the metric via `security.Fundamentals.FinancialStatements.IncomeStatement.ResearchAndDevelopment.OneYear`.\n- Must store the value in a class member variable named exactly `self.meta_annual_rnd`.\n- Must use `self.Log()` for output confirmation.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only META.\n- The update check must occur once per trading day, precisely at META's market open.\n- The annual R&D value must be stored in `self.meta_annual_rnd` (already snake_case).\n- Log message on successful update: \"META Annual R&D updated to: [value]\"\n- Log message if value is unavailable: \"META Annual R&D not available for update.\"\n- Backtest period should cover multiple fiscal years.\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, variable initialization, scheduling).\n- Implement the scheduled event handler method (`update_annual_rnd`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before updating the variable.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (retrieving and storing META's annual R&D expense daily).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, initializing `self.meta_annual_rnd`, scheduling the `update_annual_rnd` event).\n* How `Schedule.On` with `AtMarketOpen` triggers the daily update.\n* The specific API property used (`...ResearchAndDevelopment.OneYear`).\n* How the retrieved value is stored in the required class variable `self.meta_annual_rnd`.\n* How data availability is checked before accessing the metric.\n* How unavailable data is handled (no update, specific log message).\n* The exact format of the log messages for both successful updates and unavailable data."}
{"prompt_id": "FA-E-0106", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the EV/EBITDA ratio for Berkshire Hathaway B (BRK.B) daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range (e.g., 2023 using `SetStartDate`/`SetEndDate`).\n2. Add BRK.B equity data with daily resolution using `AddEquity(\"BRK.B\", ...)`.\n3. Enable fundamental data for BRK.B.\n4. Schedule an event function (`print_ev_ebitda`) to run daily, 30 minutes after market open for BRK.B.\n5. In `print_ev_ebitda`, get the BRK.B `Security` object.\n6. Check if the `Security` object and its `Fundamentals` property are available.\n7. Access the EV/EBITDA ratio (`ValuationRatios.EVEBITDA`) from the `Fundamentals` data.\n8. Check if the retrieved value is valid (not None).\n9. If valid, print the value using `self.Debug`. If invalid or unavailable, print 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"BRK.B\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"BRK.B\"), self.TimeRules.AfterMarketOpen(\"BRK.B\", 30), self.print_ev_ebitda)` for daily execution.\n- Must access the metric via `security.Fundamentals.ValuationRatios.EVEBITDA`.\n- Must use `self.Debug()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only BRK.B.\n- Printing must occur precisely 30 minutes after BRK.B's market open each trading day.\n- Print output format for available metric: \"BRK.B EVEBITDA: [value]\"\n- Print output format for unavailable metric: \"BRK.B EVEBITDA: N/A\"\n- Backtest period should be explicitly set (e.g., 2023).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`print_ev_ebitda`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before printing.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (printing BRK.B's daily EV/EBITDA ratio).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, scheduling the `print_ev_ebitda` event).\n* How the `Schedule.On` function with `AfterMarketOpen` rule triggers the daily printing.\n* The specific API property used (`Fundamentals.ValuationRatios.EVEBITDA`).\n* How the algorithm checks for data availability before accessing the metric.\n* How the algorithm handles unavailable data by printing 'N/A'.\n* The exact format of the print output for both available and unavailable cases."}
{"prompt_id": "FA-E-0107", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the Inventory Turnover TTM for Visa (V) daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range (e.g., 2023 using `SetStartDate`/`SetEndDate`).\n2. Add V equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for V.\n4. Schedule an event function (`log_inventory_turnover`) to run daily, 30 minutes after market open for V.\n5. In `log_inventory_turnover`, get the V `Security` object.\n6. Check if the `Security` object and its `Fundamentals` property are available.\n7. Access the Inventory Turnover (`OperationRatios.InventoryTurnover`) from the `Fundamentals` data.\n8. Check if the retrieved value is valid (not None).\n9. If valid, log the value using `self.Log`. If invalid or unavailable, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"V\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"V\"), self.TimeRules.AfterMarketOpen(\"V\", 30), self.log_inventory_turnover)` for daily execution.\n- Must access the metric via `security.Fundamentals.OperationRatios.InventoryTurnover`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only V.\n- Logging must occur precisely 30 minutes after V's market open each trading day.\n- Log output format for available metric: \"V InventoryTurnover TTM: [value]\"\n- Log output format for unavailable metric: \"V InventoryTurnover TTM: N/A\"\n- Backtest period should be explicitly set (e.g., 2023).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_inventory_turnover`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before logging.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging V's daily TTM Inventory Turnover).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, scheduling the `log_inventory_turnover` event).\n* How the `Schedule.On` function with `AfterMarketOpen` rule triggers the daily logging.\n* The specific API property used (`Fundamentals.OperationRatios.InventoryTurnover`).\n* How the algorithm checks for data availability before accessing the metric.\n* How the algorithm handles unavailable data by logging 'N/A'.\n* The exact format of the log output for both available and unavailable cases.\n* Any assumptions (e.g., `InventoryTurnover` represents TTM, applicability to Visa's model)."}
{"prompt_id": "FA-E-0108", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the Free Cash Flow Yield (FCF Yield) for JPMorgan Chase (JPM) daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range (e.g., 2023 using `SetStartDate`/`SetEndDate`).\n2. Add JPM equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for JPM.\n4. Create a `Chart` named 'JPM Fundamentals' and register a `Series` named 'FCF Yield'.\n5. Schedule an event function (`plot_fcf_yield`) to run daily, at market close for JPM.\n6. In `plot_fcf_yield`, get the JPM `Security` object.\n7. Check if the `Security` object and its `Fundamentals` property are available.\n8. Access the FCF Yield (`ValuationRatios.FCFYield`) from the `Fundamentals` data.\n9. Check if the retrieved value is valid (not None).\n10. If valid, plot the value using `self.Plot` on the specified chart and series.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"JPM\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `Chart('JPM Fundamentals')` and `Series('FCF Yield', SeriesType.Line, ...)` for plot setup in `Initialize`.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"JPM\"), self.TimeRules.AtMarketClose(\"JPM\"), self.plot_fcf_yield)` for daily execution.\n- Must access the metric via `security.Fundamentals.ValuationRatios.FCFYield`.\n- Must use `self.Plot('JPM Fundamentals', 'FCF Yield', value)` to plot.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only JPM.\n- Plotting must occur exactly once per trading day, at JPM's market close.\n- The plot must be named exactly 'JPM Fundamentals'.\n- The series must be named exactly 'FCF Yield'.\n- Only plot valid metric values (must check for None).\n- Backtest period should be explicitly set (e.g., 2023).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, plot creation, scheduling).\n- Implement the scheduled event handler method (`plot_fcf_yield`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before plotting.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (plotting JPM's daily FCF Yield).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, creating chart/series, scheduling the `plot_fcf_yield` event).\n* How the `Schedule.On` function with `AtMarketClose` rule triggers the daily plotting.\n* The specific API property used (`Fundamentals.ValuationRatios.FCFYield`).\n* How `self.Plot` is used with the specified chart and series names.\n* How the algorithm checks for data availability before accessing and plotting the metric.\n* Any assumptions made (e.g., `FCFYield` represents the desired period like TTM)."}
{"prompt_id": "FA-E-0109", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the Price to Cash Flow per Share Ratio (PCFSRatio) for Walmart (WMT) daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range (e.g., 2023 using `SetStartDate`/`SetEndDate`).\n2. Add WMT equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for WMT.\n4. Schedule an event function (`log_pcf_ratio`) to run daily, 30 minutes after market open for WMT.\n5. In `log_pcf_ratio`, get the WMT `Security` object.\n6. Check if the `Security` object and its `Fundamentals` property are available.\n7. Access the PCFSRatio (`ValuationRatios.PCFSRatio`) from the `Fundamentals` data.\n8. Check if the retrieved value is valid (not None).\n9. If valid, log the value using `self.Log`. If invalid or unavailable, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"WMT\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"WMT\"), self.TimeRules.AfterMarketOpen(\"WMT\", 30), self.log_pcf_ratio)` for daily execution.\n- Must access the metric via `security.Fundamentals.ValuationRatios.PCFSRatio`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only WMT.\n- Logging must occur precisely 30 minutes after WMT's market open each trading day.\n- Log output format for available metric: \"WMT PCFSRatio: [value]\"\n- Log output format for unavailable metric: \"WMT PCFSRatio: N/A\"\n- Backtest period should be explicitly set (e.g., 2023).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_pcf_ratio`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before logging.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging WMT's daily PCFSRatio).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, scheduling the `log_pcf_ratio` event).\n* How the `Schedule.On` function with `AfterMarketOpen` rule triggers the daily logging.\n* The specific API property used (`Fundamentals.ValuationRatios.PCFSRatio`).\n* How the algorithm checks for data availability before accessing the metric.\n* How the algorithm handles unavailable data by logging 'N/A'.\n* The exact format of the log output for both available and unavailable cases."}
{"prompt_id": "FA-E-0110", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the Headquarter City for Procter & Gamble (PG) during initialization.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a start date (e.g., using `SetStartDate`).\n2. Add PG equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for PG.\n4. Immediately after adding the equity, retrieve the PG `Security` object.\n5. Check if the `Security` object and its `Fundamentals` property are available.\n6. Access the Headquarter City (`CompanyReference.HeadquarterCity`) from the `Fundamentals` data.\n7. Check if the retrieved city name is valid (not None or empty).\n8. If valid, print the city name using `self.Debug`. If invalid or unavailable, print 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"PG\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must access the metric via `self.Securities[\"PG\"].Fundamentals.CompanyReference.HeadquarterCity` *within `Initialize`*.\n- Must use `self.Debug()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only PG.\n- Fetching and printing must occur *only once* during the `Initialize` phase.\n- Print output format for available city: \"PG HeadquarterCity: [value]\"\n- Print output format for unavailable city: \"PG HeadquarterCity: N/A\"\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date, data request, enabling fundamentals, retrieval logic).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks immediately after `AddEquity` for data availability (`security`, `security.Fundamentals`) before accessing the metric.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (printing PG's Headquarter City at initialization).\n* Key setup steps in `Initialize` (date, adding equity, enabling fundamental data).\n* Why the retrieval happens within `Initialize`.\n* The specific API property used (`Fundamentals.CompanyReference.HeadquarterCity`).\n* How the algorithm checks for the availability of the Security object and its fundamental data.\n* How the algorithm handles unavailable data by printing 'N/A'.\n* The exact format of the print output for both available and unavailable cases."}
{"prompt_id": "FA-E-0111", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the annual Interest Expense for UnitedHealth Group (UNH) daily (logging the currently known value).\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range covering at least two fiscal years (e.g., 2022-2023 using `SetStartDate`/`SetEndDate`).\n2. Add UNH equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for UNH.\n4. Schedule an event function (`log_interest_expense`) to run daily, 30 minutes after market open for UNH.\n5. In `log_interest_expense`, get the UNH `Security` object.\n6. Check if the `Security` object and its `Fundamentals` property are available.\n7. Access the annual Interest Expense (`FinancialStatements.IncomeStatement.InterestExpense.OneYear`) from `Fundamentals`.\n8. Check if the retrieved value is valid (not None).\n9. If valid, log the value using `self.Log`. If invalid or unavailable, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"UNH\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"UNH\"), self.TimeRules.AfterMarketOpen(\"UNH\", 30), self.log_interest_expense)` for daily execution.\n- Must access the metric via `security.Fundamentals.FinancialStatements.IncomeStatement.InterestExpense.OneYear`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only UNH.\n- Logging must occur precisely 30 minutes after UNH's market open each trading day.\n- Log output format for available metric: \"UNH Annual Interest Expense: [value]\"\n- Log output format for unavailable metric: \"UNH Annual Interest Expense: N/A\"\n- Backtest period should cover multiple fiscal years.\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_interest_expense`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before logging.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging UNH's daily known annual Interest Expense).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, scheduling the `log_interest_expense` event).\n* How the `Schedule.On` function with `AfterMarketOpen` rule triggers the daily logging.\n* The specific API property used (`...InterestExpense.OneYear`).\n* How the algorithm checks for data availability before accessing the metric.\n* How the algorithm handles unavailable data by logging 'N/A'.\n* The exact format of the log output for both available and unavailable cases."}
{"prompt_id": "FA-E-0112", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the Price Fair Value for Apple (AAPL) daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range (e.g., 2023 using `SetStartDate`/`SetEndDate`).\n2. Add AAPL equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for AAPL.\n4. Create a `Chart` named 'AAPL Fundamentals' and register a `Series` named 'Price Fair Value'.\n5. Schedule an event function (`plot_fair_value`) to run daily, at market close for AAPL.\n6. In `plot_fair_value`, get the AAPL `Security` object.\n7. Check if the `Security` object and its `Fundamentals` property are available.\n8. Access the Price Fair Value (`ValuationRatios.PriceFairValue`) from the `Fundamentals` data.\n9. Check if the retrieved value is valid (not None).\n10. If valid, plot the value using `self.Plot` on the specified chart and series.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"AAPL\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `Chart('AAPL Fundamentals')` and `Series('Price Fair Value', SeriesType.Line, ...)` for plot setup in `Initialize`.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"AAPL\"), self.TimeRules.AtMarketClose(\"AAPL\"), self.plot_fair_value)` for daily execution.\n- Must access the metric via `security.Fundamentals.ValuationRatios.PriceFairValue`.\n- Must use `self.Plot('AAPL Fundamentals', 'Price Fair Value', value)` to plot.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only AAPL.\n- Plotting must occur exactly once per trading day, at AAPL's market close.\n- The plot must be named exactly 'AAPL Fundamentals'.\n- The series must be named exactly 'Price Fair Value'.\n- Only plot valid metric values (must check for None).\n- Backtest period should be explicitly set (e.g., 2023).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, plot creation, scheduling).\n- Implement the scheduled event handler method (`plot_fair_value`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before plotting.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (plotting AAPL's daily Price Fair Value).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, creating chart/series, scheduling the `plot_fair_value` event).\n* How the `Schedule.On` function with `AtMarketClose` rule triggers the daily plotting.\n* The specific API property used (`Fundamentals.ValuationRatios.PriceFairValue`).\n* How `self.Plot` is used with the specified chart and series names.\n* How the algorithm checks for data availability before accessing and plotting the metric.\n* Any assumptions made (e.g., regarding the calculation method of PriceFairValue)."}
{"prompt_id": "FA-E-0113", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to retrieve and store the TTM Selling, General & Administrative expense for Microsoft (MSFT) daily, logging the stored value.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range (e.g., 2023 using `SetStartDate`/`SetEndDate`).\n2. Add MSFT equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for MSFT.\n4. Declare a class member variable `self.msft_ttm_sga` initialized to `None`.\n5. Schedule an event function (`update_ttm_sga`) to run daily, at market open for MSFT.\n6. In `update_ttm_sga`, get the MSFT `Security` object.\n7. Check if the `Security` object and its `Fundamentals` property are available.\n8. Access the TTM SG&A expense (`FinancialStatements.IncomeStatement.SellingGeneralAndAdministrative.TwelveMonths`) from `Fundamentals`.\n9. Check if the retrieved value is valid (not None).\n10. If valid, update `self.msft_ttm_sga` with the value and log the *newly stored* value.\n11. If invalid or unavailable, log that the value was not updated/available.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"MSFT\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"MSFT\"), self.TimeRules.AtMarketOpen(\"MSFT\"), self.update_ttm_sga)`.\n- Must access the metric via `security.Fundamentals.FinancialStatements.IncomeStatement.SellingGeneralAndAdministrative.TwelveMonths`.\n- Must store the value in a class member variable named exactly `self.msft_ttm_sga` (already snake_case).\n- Must use `self.Log()` for output confirmation.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only MSFT.\n- The update check must occur once per trading day, precisely at MSFT's market open.\n- The TTM SG&A value must be stored in `self.msft_ttm_sga`.\n- Log message on successful update: \"MSFT TTM SG&A updated to: [value]\"\n- Log message if value is unavailable: \"MSFT TTM SG&A not available for update.\"\n- Backtest period should be explicitly set (e.g., 2023).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, variable initialization, scheduling).\n- Implement the scheduled event handler method (`update_ttm_sga`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before updating the variable.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (retrieving and storing MSFT's TTM SG&A expense daily).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, initializing `self.msft_ttm_sga`, scheduling the `update_ttm_sga` event).\n* How `Schedule.On` with `AtMarketOpen` triggers the daily update.\n* The specific API property used (`...SellingGeneralAndAdministrative.TwelveMonths`).\n* How the retrieved value is stored in the required class variable `self.msft_ttm_sga`.\n* How data availability is checked before accessing the metric.\n* How unavailable data is handled (no update, specific log message).\n* The exact format of the log messages for both successful updates and unavailable data."}
{"prompt_id": "FA-E-0114", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the Revenue Growth (3-year average) for Alphabet (GOOG) daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range (e.g., 2023 using `SetStartDate`/`SetEndDate`).\n2. Add GOOG equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for GOOG.\n4. Schedule an event function (`print_revenue_growth_3y`) to run daily, 30 minutes after market open for GOOG.\n5. In `print_revenue_growth_3y`, get the GOOG `Security` object.\n6. Check if the `Security` object and its `Fundamentals` property are available.\n7. Access the 3-Year Revenue Growth (`OperationRatios.RevenueGrowth.ThreeYear`) from `Fundamentals`. *Verify this exact path.* \n8. Check if the retrieved value is valid (not None).\n9. If valid, print the value using `self.Debug`. If invalid or unavailable, print 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"GOOG\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"GOOG\"), self.TimeRules.AfterMarketOpen(\"GOOG\", 30), self.print_revenue_growth_3y)` for daily execution.\n- Must access the metric via `security.Fundamentals.OperationRatios.RevenueGrowth.ThreeYear` (or the confirmed correct path).\n- Must use `self.Debug()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only GOOG.\n- Printing must occur precisely 30 minutes after GOOG's market open each trading day.\n- Print output format for available metric: \"GOOG RevenueGrowth (3yr): [value]\"\n- Print output format for unavailable metric: \"GOOG RevenueGrowth (3yr): N/A\"\n- Backtest period should be explicitly set (e.g., 2023).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`print_revenue_growth_3y`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before printing.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (printing GOOG's daily 3Y Avg Revenue Growth).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, scheduling the `print_revenue_growth_3y` event).\n* How the `Schedule.On` function with `AfterMarketOpen` rule triggers the daily printing.\n* The specific API property used (`...RevenueGrowth.ThreeYear` or confirmed path).\n* How the algorithm checks for data availability before accessing the metric.\n* How the algorithm handles unavailable data by printing 'N/A'.\n* The exact format of the print output for both available and unavailable cases.\n* Confirmation or assumption about the exact API path used."}
{"prompt_id": "FA-E-0115", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the annual Capital Expenditure for Amazon (AMZN) daily (logging the currently known value).\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range covering at least two fiscal years (e.g., 2022-2023 using `SetStartDate`/`SetEndDate`).\n2. Add AMZN equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for AMZN.\n4. Schedule an event function (`log_annual_capex`) to run daily, 30 minutes after market open for AMZN.\n5. In `log_annual_capex`, get the AMZN `Security` object.\n6. Check if the `Security` object and its `Fundamentals` property are available.\n7. Access the annual Capital Expenditure (`FinancialStatements.CashFlowStatement.CapitalExpenditure.OneYear`) from `Fundamentals`.\n8. Check if the retrieved value is valid (not None).\n9. If valid, log the value using `self.Log`. If invalid or unavailable, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"AMZN\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"AMZN\"), self.TimeRules.AfterMarketOpen(\"AMZN\", 30), self.log_annual_capex)` for daily execution.\n- Must access the metric via `security.Fundamentals.FinancialStatements.CashFlowStatement.CapitalExpenditure.OneYear`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only AMZN.\n- Logging must occur precisely 30 minutes after AMZN's market open each trading day.\n- Log output format for available metric: \"AMZN Annual CapEx: [value]\"\n- Log output format for unavailable metric: \"AMZN Annual CapEx: N/A\"\n- Backtest period should cover multiple fiscal years.\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_annual_capex`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before logging.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging AMZN's daily known annual CapEx).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, scheduling the `log_annual_capex` event).\n* How the `Schedule.On` function with `AfterMarketOpen` rule triggers the daily logging.\n* The specific API property used (`...CapitalExpenditure.OneYear`).\n* How the algorithm checks for data availability before accessing the metric.\n* How the algorithm handles unavailable data by logging 'N/A'.\n* The exact format of the log output for both available and unavailable cases."}
{"prompt_id": "FA-E-0116", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the 1-Month Price Change percentage for Tesla (TSLA) daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range (e.g., 2023 using `SetStartDate`/`SetEndDate`).\n2. Add TSLA equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for TSLA.\n4. Create a `Chart` named 'TSLA Performance' and register a `Series` named 'Price Change 1M'.\n5. Schedule an event function (`plot_price_change_1m`) to run daily, at market close for TSLA.\n6. In `plot_price_change_1m`, get the TSLA `Security` object.\n7. Check if the `Security` object and its `Fundamentals` property are available.\n8. Access the 1-Month Price Change (`PerformanceRatios.PriceChange1M`) from the `Fundamentals` data.\n9. Check if the retrieved value is valid (not None).\n10. If valid, plot the value using `self.Plot` on the specified chart and series.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"TSLA\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `Chart('TSLA Performance')` and `Series('Price Change 1M', SeriesType.Line, ...)` for plot setup in `Initialize`.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"TSLA\"), self.TimeRules.AtMarketClose(\"TSLA\"), self.plot_price_change_1m)` for daily execution.\n- Must access the metric via `security.Fundamentals.PerformanceRatios.PriceChange1M`.\n- Must use `self.Plot('TSLA Performance', 'Price Change 1M', value)` to plot.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only TSLA.\n- Plotting must occur exactly once per trading day, at TSLA's market close.\n- The plot must be named exactly 'TSLA Performance'.\n- The series must be named exactly 'Price Change 1M'.\n- Only plot valid metric values (must check for None).\n- Backtest period should be explicitly set (e.g., 2023).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, plot creation, scheduling).\n- Implement the scheduled event handler method (`plot_price_change_1m`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before plotting.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (plotting TSLA's daily 1M Price Change %).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, creating chart/series, scheduling the `plot_price_change_1m` event).\n* How the `Schedule.On` function with `AtMarketClose` rule triggers the daily plotting.\n* The specific API property used (`Fundamentals.PerformanceRatios.PriceChange1M`).\n* How `self.Plot` is used with the specified chart and series names.\n* How the algorithm checks for data availability before accessing and plotting the metric."}
{"prompt_id": "FA-E-0117", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the annual Cost Of Revenue for Nvidia (NVDA) daily (logging the currently known value).\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range covering at least two fiscal years (e.g., 2022-2023 using `SetStartDate`/`SetEndDate`).\n2. Add NVDA equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for NVDA.\n4. Schedule an event function (`log_annual_cor`) to run daily, 30 minutes after market open for NVDA.\n5. In `log_annual_cor`, get the NVDA `Security` object.\n6. Check if the `Security` object and its `Fundamentals` property are available.\n7. Access the annual Cost Of Revenue (`FinancialStatements.IncomeStatement.CostOfRevenue.OneYear`) from `Fundamentals`.\n8. Check if the retrieved value is valid (not None).\n9. If valid, log the value using `self.Log`. If invalid or unavailable, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"NVDA\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"NVDA\"), self.TimeRules.AfterMarketOpen(\"NVDA\", 30), self.log_annual_cor)` for daily execution.\n- Must access the metric via `security.Fundamentals.FinancialStatements.IncomeStatement.CostOfRevenue.OneYear`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only NVDA.\n- Logging must occur precisely 30 minutes after NVDA's market open each trading day.\n- Log output format for available metric: \"NVDA Annual CostOfRevenue: [value]\"\n- Log output format for unavailable metric: \"NVDA Annual CostOfRevenue: N/A\"\n- Backtest period should cover multiple fiscal years.\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_annual_cor`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before logging.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging NVDA's daily known annual Cost of Revenue).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, scheduling the `log_annual_cor` event).\n* How the `Schedule.On` function with `AfterMarketOpen` rule triggers the daily logging.\n* The specific API property used (`...CostOfRevenue.OneYear`).\n* How the algorithm checks for data availability before accessing the metric.\n* How the algorithm handles unavailable data by logging 'N/A'.\n* The exact format of the log output for both available and unavailable cases."}
{"prompt_id": "FA-E-0118", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the ROIC TTM for Johnson & Johnson (JNJ) daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range (e.g., 2023 using `SetStartDate`/`SetEndDate`).\n2. Add JNJ equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for JNJ.\n4. Schedule an event function (`print_roic`) to run daily, 30 minutes after market open for JNJ.\n5. In `print_roic`, get the JNJ `Security` object.\n6. Check if the `Security` object and its `Fundamentals` property are available.\n7. Access the ROIC (`OperationRatios.ROIC`) from the `Fundamentals` data.\n8. Check if the retrieved value is valid (not None).\n9. If valid, print the value using `self.Debug`. If invalid or unavailable, print 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"JNJ\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"JNJ\"), self.TimeRules.AfterMarketOpen(\"JNJ\", 30), self.print_roic)` for daily execution.\n- Must access the metric via `security.Fundamentals.OperationRatios.ROIC`.\n- Must use `self.Debug()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only JNJ.\n- Printing must occur precisely 30 minutes after JNJ's market open each trading day.\n- Print output format for available metric: \"JNJ ROIC TTM: [value]\"\n- Print output format for unavailable metric: \"JNJ ROIC TTM: N/A\"\n- Backtest period should be explicitly set (e.g., 2023).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`print_roic`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before printing.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (printing JNJ's daily TTM ROIC).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, scheduling the `print_roic` event).\n* How the `Schedule.On` function with `AfterMarketOpen` rule triggers the daily printing.\n* The specific API property used (`Fundamentals.OperationRatios.ROIC`).\n* How the algorithm checks for data availability before accessing the metric.\n* How the algorithm handles unavailable data by printing 'N/A'.\n* The exact format of the print output for both available and unavailable cases."}
{"prompt_id": "FA-E-0119", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the Pretax Margin TTM for Meta Platforms (META) daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range (e.g., 2023 using `SetStartDate`/`SetEndDate`).\n2. Add META equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for META.\n4. Schedule an event function (`log_pretax_margin`) to run daily, 30 minutes after market open for META.\n5. In `log_pretax_margin`, get the META `Security` object.\n6. Check if the `Security` object and its `Fundamentals` property are available.\n7. Access the Pretax Margin (`OperationRatios.PretaxMargin`) from the `Fundamentals` data.\n8. Check if the retrieved value is valid (not None).\n9. If valid, log the value using `self.Log`. If invalid or unavailable, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"META\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"META\"), self.TimeRules.AfterMarketOpen(\"META\", 30), self.log_pretax_margin)` for daily execution.\n- Must access the metric via `security.Fundamentals.OperationRatios.PretaxMargin`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only META.\n- Logging must occur precisely 30 minutes after META's market open each trading day.\n- Log output format for available metric: \"META PretaxMargin TTM: [value]\"\n- Log output format for unavailable metric: \"META PretaxMargin TTM: N/A\"\n- Backtest period should be explicitly set (e.g., 2023).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_pretax_margin`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before logging.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging META's daily TTM Pretax Margin).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, scheduling the `log_pretax_margin` event).\n* How the `Schedule.On` function with `AfterMarketOpen` rule triggers the daily logging.\n* The specific API property used (`Fundamentals.OperationRatios.PretaxMargin`).\n* How the algorithm checks for data availability before accessing the metric.\n* How the algorithm handles unavailable data by logging 'N/A'.\n* The exact format of the log output for both available and unavailable cases."}
{"prompt_id": "FA-E-0120", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the annual Income Tax Expense for Berkshire Hathaway B (BRK.B) daily (plotting the currently known value).\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range covering at least two fiscal years (e.g., 2022-2023 using `SetStartDate`/`SetEndDate`).\n2. Add BRK.B equity data with daily resolution using `AddEquity(\"BRK.B\", ...)`.\n3. Enable fundamental data for BRK.B.\n4. Create a `Chart` named 'BRK.B Financials' and register a `Series` named 'Annual Income Tax'.\n5. Schedule an event function (`plot_annual_tax`) to run daily, at market close for BRK.B.\n6. In `plot_annual_tax`, get the BRK.B `Security` object.\n7. Check if the `Security` object and its `Fundamentals` property are available.\n8. Access the annual Income Tax Expense (`FinancialStatements.IncomeStatement.IncomeTaxExpense.OneYear`) from `Fundamentals`.\n9. Check if the retrieved value is valid (not None).\n10. If valid, plot the value using `self.Plot` on the specified chart and series.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"BRK.B\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `Chart('BRK.B Financials')` and `Series('Annual Income Tax', SeriesType.Line, ...)` for plot setup in `Initialize`.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"BRK.B\"), self.TimeRules.AtMarketClose(\"BRK.B\"), self.plot_annual_tax)` for daily execution.\n- Must access the metric via `security.Fundamentals.FinancialStatements.IncomeStatement.IncomeTaxExpense.OneYear`.\n- Must use `self.Plot('BRK.B Financials', 'Annual Income Tax', value)` to plot.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only BRK.B.\n- Plotting must occur exactly once per trading day, at BRK.B's market close.\n- The plot must be named exactly 'BRK.B Financials'.\n- The series must be named exactly 'Annual Income Tax'.\n- Only plot valid metric values (must check for None).\n- Backtest period should cover multiple fiscal years.\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, plot creation, scheduling).\n- Implement the scheduled event handler method (`plot_annual_tax`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before plotting.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (plotting BRK.B's daily known annual Income Tax Expense).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, creating chart/series, scheduling the `plot_annual_tax` event).\n* How the `Schedule.On` function with `AtMarketClose` rule triggers the daily plotting.\n* The specific API property used (`...IncomeTaxExpense.OneYear`).\n* How `self.Plot` is used with the specified chart and series names.\n* How the algorithm checks for data availability before accessing and plotting the metric."}
{"prompt_id": "FA-E-0121", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to retrieve and store the Cash And Cash Equivalents for Visa (V) daily, logging the stored value.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range (e.g., 2023 using `SetStartDate`/`SetEndDate`).\n2. Add V equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for V.\n4. Declare a class member variable `self.v_latest_cash` initialized to `None`.\n5. Schedule an event function (`update_cash`) to run daily, at market open for V.\n6. In `update_cash`, get the V `Security` object.\n7. Check if the `Security` object and its `Fundamentals` property are available.\n8. Access the Cash And Cash Equivalents (`FinancialStatements.BalanceSheet.CashAndCashEquivalents`) from `Fundamentals`.\n9. Check if the retrieved value is valid (not None).\n10. If valid, update `self.v_latest_cash` with the value and log the *newly stored* value.\n11. If invalid or unavailable, log that the value was not updated/available.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"V\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"V\"), self.TimeRules.AtMarketOpen(\"V\"), self.update_cash)`.\n- Must access the metric via `security.Fundamentals.FinancialStatements.BalanceSheet.CashAndCashEquivalents`.\n- Must store the value in a class member variable named exactly `self.v_latest_cash` (already snake_case).\n- Must use `self.Log()` for output confirmation.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only V.\n- The update check must occur once per trading day, precisely at V's market open.\n- The Cash value must be stored in `self.v_latest_cash`.\n- Log message on successful update: \"V CashAndCashEquivalents updated to: [value]\"\n- Log message if value is unavailable: \"V CashAndCashEquivalents not available for update.\"\n- Backtest period should be explicitly set (e.g., 2023).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, variable initialization, scheduling).\n- Implement the scheduled event handler method (`update_cash`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before updating the variable.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (retrieving and storing V's Cash & Cash Equivalents daily).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, initializing `self.v_latest_cash`, scheduling the `update_cash` event).\n* How `Schedule.On` with `AtMarketOpen` triggers the daily update.\n* The specific API property used (`...CashAndCashEquivalents`).\n* How the retrieved value is stored in the required class variable `self.v_latest_cash`.\n* How data availability is checked before accessing the metric.\n* How unavailable data is handled (no update, specific log message).\n* The exact format of the log messages for both successful updates and unavailable data."}
{"prompt_id": "FA-E-0122", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the Goodwill for JPMorgan Chase (JPM) during initialization.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a start date (e.g., using `SetStartDate`).\n2. Add JPM equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for JPM.\n4. Immediately after adding the equity, retrieve the JPM `Security` object.\n5. Check if the `Security` object and its `Fundamentals` property are available.\n6. Access the Goodwill (`FinancialStatements.BalanceSheet.Goodwill`) from the `Fundamentals` data.\n7. Check if the retrieved value is valid (not None).\n8. If valid, print the value using `self.Debug`. If invalid or unavailable, print 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"JPM\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must access the metric via `self.Securities[\"JPM\"].Fundamentals.FinancialStatements.BalanceSheet.Goodwill` *within `Initialize`*.\n- Must use `self.Debug()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only JPM.\n- Fetching and printing must occur *only once* during the `Initialize` phase.\n- Print output format for available value: \"JPM Goodwill: [value]\"\n- Print output format for unavailable value: \"JPM Goodwill: N/A\"\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date, data request, enabling fundamentals, retrieval logic).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks immediately after `AddEquity` for data availability (`security`, `security.Fundamentals`) before accessing the metric.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (printing JPM's Goodwill at initialization).\n* Key setup steps in `Initialize` (date, adding equity, enabling fundamental data).\n* Why the retrieval happens within `Initialize`.\n* The specific API property used (`...BalanceSheet.Goodwill`).\n* How the algorithm checks for the availability of the Security object and its fundamental data.\n* How the algorithm handles unavailable data by printing 'N/A'.\n* The exact format of the print output for both available and unavailable cases."}
{"prompt_id": "FA-E-0123", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the Long Term Debt for Walmart (WMT) daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range (e.g., 2023 using `SetStartDate`/`SetEndDate`).\n2. Add WMT equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for WMT.\n4. Schedule an event function (`log_ltd`) to run daily, 30 minutes after market open for WMT.\n5. In `log_ltd`, get the WMT `Security` object.\n6. Check if the `Security` object and its `Fundamentals` property are available.\n7. Access the Long Term Debt (`FinancialStatements.BalanceSheet.LongTermDebt`) from `Fundamentals`.\n8. Check if the retrieved value is valid (not None).\n9. If valid, log the value using `self.Log`. If invalid or unavailable, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"WMT\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"WMT\"), self.TimeRules.AfterMarketOpen(\"WMT\", 30), self.log_ltd)` for daily execution.\n- Must access the metric via `security.Fundamentals.FinancialStatements.BalanceSheet.LongTermDebt`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only WMT.\n- Logging must occur precisely 30 minutes after WMT's market open each trading day.\n- Log output format for available metric: \"WMT LongTermDebt: [value]\"\n- Log output format for unavailable metric: \"WMT LongTermDebt: N/A\"\n- Backtest period should be explicitly set (e.g., 2023).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_ltd`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before logging.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging WMT's daily Long Term Debt).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, scheduling the `log_ltd` event).\n* How the `Schedule.On` function with `AfterMarketOpen` rule triggers the daily logging.\n* The specific API property used (`...BalanceSheet.LongTermDebt`).\n* How the algorithm checks for data availability before accessing the metric.\n* How the algorithm handles unavailable data by logging 'N/A'.\n* The exact format of the log output for both available and unavailable cases."}
{"prompt_id": "FA-E-0124", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the Retained Earnings for Procter & Gamble (PG) daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range (e.g., 2023 using `SetStartDate`/`SetEndDate`).\n2. Add PG equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for PG.\n4. Create a `Chart` named 'PG Financials' and register a `Series` named 'Retained Earnings'.\n5. Schedule an event function (`plot_retained_earnings`) to run daily, at market close for PG.\n6. In `plot_retained_earnings`, get the PG `Security` object.\n7. Check if the `Security` object and its `Fundamentals` property are available.\n8. Access the Retained Earnings (`FinancialStatements.BalanceSheet.RetainedEarnings`) from `Fundamentals`.\n9. Check if the retrieved value is valid (not None).\n10. If valid, plot the value using `self.Plot` on the specified chart and series.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"PG\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `Chart('PG Financials')` and `Series('Retained Earnings', SeriesType.Line, ...)` for plot setup in `Initialize`.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"PG\"), self.TimeRules.AtMarketClose(\"PG\"), self.plot_retained_earnings)` for daily execution.\n- Must access the metric via `security.Fundamentals.FinancialStatements.BalanceSheet.RetainedEarnings`.\n- Must use `self.Plot('PG Financials', 'Retained Earnings', value)` to plot.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only PG.\n- Plotting must occur exactly once per trading day, at PG's market close.\n- The plot must be named exactly 'PG Financials'.\n- The series must be named exactly 'Retained Earnings'.\n- Only plot valid metric values (must check for None).\n- Backtest period should be explicitly set (e.g., 2023).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, plot creation, scheduling).\n- Implement the scheduled event handler method (`plot_retained_earnings`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before plotting.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (plotting PG's daily Retained Earnings).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, creating chart/series, scheduling the `plot_retained_earnings` event).\n* How the `Schedule.On` function with `AtMarketClose` rule triggers the daily plotting.\n* The specific API property used (`...BalanceSheet.RetainedEarnings`).\n* How `self.Plot` is used with the specified chart and series names.\n* How the algorithm checks for data availability before accessing and plotting the metric."}
{"prompt_id": "FA-E-0125", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the Current Assets for UnitedHealth Group (UNH) daily.\n\n**Core Logic Steps:**\n1. In `Initialize`, set a date range (e.g., 2023 using `SetStartDate`/`SetEndDate`).\n2. Add UNH equity data with daily resolution using `AddEquity`.\n3. Enable fundamental data for UNH.\n4. Schedule an event function (`log_current_assets`) to run daily, 30 minutes after market open for UNH.\n5. In `log_current_assets`, get the UNH `Security` object.\n6. Check if the `Security` object and its `Fundamentals` property are available.\n7. Access the Current Assets (`FinancialStatements.BalanceSheet.CurrentAssets`) from `Fundamentals`.\n8. Check if the retrieved value is valid (not None).\n9. If valid, log the value using `self.Log`. If invalid or unavailable, log 'N/A'.\n\n**Specific LEAN API Usage:**\n- Must use `self.SetStartDate(YYYY, MM, DD)` and `self.SetEndDate(YYYY, MM, DD)`.\n- Must use `self.AddEquity(\"UNH\", Resolution.Daily)`.\n- Must ensure fundamental data is enabled.\n- Must use `self.Schedule.On(self.DateRules.EveryDay(\"UNH\"), self.TimeRules.AfterMarketOpen(\"UNH\", 30), self.log_current_assets)` for daily execution.\n- Must access the metric via `security.Fundamentals.FinancialStatements.BalanceSheet.CurrentAssets`.\n- Must use `self.Log()` for output.\n\n**Explicit Constraints and Formatting:**\n- The algorithm must target only UNH.\n- Logging must occur precisely 30 minutes after UNH's market open each trading day.\n- Log output format for available metric: \"UNH CurrentAssets: [value]\"\n- Log output format for unavailable metric: \"UNH CurrentAssets: N/A\"\n- Backtest period should be explicitly set (e.g., 2023).\n\n**Essential Supporting Components:**\n- Include the `Initialize` method with necessary setup (date range, data request, enabling fundamentals, scheduling).\n- Implement the scheduled event handler method (`log_current_assets`).\n- Ensure the `QCAlgorithm` class structure is correctly implemented.\n- Include checks for data availability (`security`, `security.Fundamentals`, and the metric value) before logging.\n\n**Required Explanation:**\nProvide a detailed explanation covering AT LEAST:\n* The overall purpose of the algorithm (logging UNH's daily Current Assets).\n* Key setup steps in `Initialize` (date range, adding equity, enabling fundamental data, scheduling the `log_current_assets` event).\n* How the `Schedule.On` function with `AfterMarketOpen` rule triggers the daily logging.\n* The specific API property used (`...BalanceSheet.CurrentAssets`).\n* How the algorithm checks for data availability before accessing the metric.\n* How the algorithm handles unavailable data by logging 'N/A'.\n* The exact format of the log output for both available and unavailable cases."}
{"prompt_id": "FA-E-0126", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the CurrentLiabilities for AAPL."}
{"prompt_id": "FA-E-0127", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to store the CommonStockEquity for MSFT daily."}
{"prompt_id": "FA-E-0128", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the TotalLiabilitiesNetMinorityInterest for GOOG."}
{"prompt_id": "FA-E-0129", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the Inventories value for AMZN daily."}
{"prompt_id": "FA-E-0130", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the annual IssuanceOfCapitalStock for TSLA."}
{"prompt_id": "FA-E-0131", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the annual RepurchaseOfCapitalStock for NVDA."}
{"prompt_id": "FA-E-0132", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the annual PaymentOfCashDividends for JNJ."}
{"prompt_id": "FA-E-0133", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the TTM InvestingCashFlow for META."}
{"prompt_id": "FA-E-0134", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the TTM FinancingCashFlow for BRK.B daily."}
{"prompt_id": "FA-E-0135", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the DaysSalesOutstanding TTM for V daily."}
{"prompt_id": "FA-E-0136", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the DaysInventoryOutstanding TTM for JPM daily."}
{"prompt_id": "FA-E-0137", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the DaysPayablesOutstanding TTM for WMT daily."}
{"prompt_id": "FA-E-0138", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the InterestCoverage TTM for PG daily."}
{"prompt_id": "FA-E-0139", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to store the GrossMargin TTM for UNH."}
{"prompt_id": "FA-E-0140", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the NetIncomeApplicableToCommonShares (Annual) for AAPL."}
{"prompt_id": "FA-E-0141", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm that retrieves and logs the daily P/E ratio for MSFT."}
{"prompt_id": "FA-E-0142", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN Python algorithm to fetch and print the current Market Cap for GOOG during initialization."}
{"prompt_id": "FA-E-0143", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN Python script that plots the TTM Revenue for TSLA daily."}
{"prompt_id": "FA-E-0144", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a LEAN Python algorithm that accesses and logs the Debt-to-Equity ratio for NVDA every trading day."}
{"prompt_id": "FA-E-0145", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that gets and stores the latest Dividend Yield for META in a variable daily."}
{"prompt_id": "FA-E-0146", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN Python script to log the P/B ratio for BRK.B each day."}
{"prompt_id": "FA-E-0147", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm that fetches and plots the annual Net Income for V when fundamental data is updated."}
{"prompt_id": "FA-E-0148", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python algorithm to print the Sector Name for JPM during the `Initialize` method."}
{"prompt_id": "FA-E-0149", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect script that retrieves and logs the ROE for WMT daily."}
{"prompt_id": "FA-E-0150", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that plots the Quick Ratio for PG every trading day."}
{"prompt_id": "FA-E-0151", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and log the EPS TTM for UNH daily."}
{"prompt_id": "FA-E-0152", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the current Total Assets for AAPL during initialization."}
{"prompt_id": "FA-E-0153", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that plots the Operating Margin TTM for MSFT daily."}
{"prompt_id": "FA-E-0154", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that retrieves and logs the P/S ratio for GOOG daily."}
{"prompt_id": "FA-E-0155", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and print the Industry Name for AMZN in the `Initialize` function."}
{"prompt_id": "FA-E-0156", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to log the annual Free Cash Flow for TSLA when fundamental data becomes available."}
{"prompt_id": "FA-E-0157", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that plots the Current Ratio for NVDA daily."}
{"prompt_id": "FA-E-0158", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that retrieves and logs the Book Value Per Share for JNJ every trading day."}
{"prompt_id": "FA-E-0159", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and store the Beta value for META in a variable daily."}
{"prompt_id": "FA-E-0160", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the latest TTM Operating Cash Flow for BRK.B during initialization."}
{"prompt_id": "FA-E-0161", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that logs the ROA TTM for V daily."}
{"prompt_id": "FA-E-0162", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that plots the annual Gross Profit for JPM when new fundamental data arrives."}
{"prompt_id": "FA-E-0163", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and log the Shares Outstanding for WMT daily."}
{"prompt_id": "FA-E-0164", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the CIK number for PG during algorithm initialization."}
{"prompt_id": "FA-E-0165", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that retrieves and plots the Payout Ratio for UNH daily, if available."}
{"prompt_id": "FA-E-0166", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that logs the Sales Per Share TTM for AAPL every trading day."}
{"prompt_id": "FA-E-0167", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and store the latest annual Total Liabilities for MSFT in a variable."}
{"prompt_id": "FA-E-0168", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the PEG Ratio for GOOG daily if the value is positive."}
{"prompt_id": "FA-E-0169", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that logs the Asset Turnover TTM for AMZN daily."}
{"prompt_id": "FA-E-0170", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that plots the EBITDA TTM for TSLA when fundamental data is updated."}
{"prompt_id": "FA-E-0171", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and log the Net Margin TTM for NVDA daily and compare to industry average."}
{"prompt_id": "FA-E-0172", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the Country ID for JNJ during initialization."}
{"prompt_id": "FA-E-0173", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that retrieves and plots the Cash Return for META daily."}
{"prompt_id": "FA-E-0174", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that logs the Earnings Yield for BRK.B every trading day."}
{"prompt_id": "FA-E-0175", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and store the latest annual Research And Development expense for V."}
{"prompt_id": "FA-E-0176", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the EV/EBITDA ratio for JPM daily."}
{"prompt_id": "FA-E-0177", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that logs the Inventory Turnover TTM for WMT daily."}
{"prompt_id": "FA-E-0178", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that plots the FCFYield for PG daily."}
{"prompt_id": "FA-E-0179", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and log the PCFSRatio for UNH daily."}
{"prompt_id": "FA-E-0180", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the Headquarters City for AAPL during initialization."}
{"prompt_id": "FA-E-0181", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that retrieves and logs the annual Interest Expense for MSFT."}
{"prompt_id": "FA-E-0182", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that plots the Price Fair Value (Morningstar) for GOOG daily, if available."}
{"prompt_id": "FA-E-0183", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and store the latest TTM Selling, General & Administrative expense for AMZN."}
{"prompt_id": "FA-E-0184", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the Revenue Growth (3 year average) for TSLA daily."}
{"prompt_id": "FA-E-0185", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that logs the annual Capital Expenditures for NVDA when fundamental data arrives."}
{"prompt_id": "FA-E-0186", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that plots the Price Change 1 Month for JNJ daily."}
{"prompt_id": "FA-E-0187", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and log the annual Cost of Revenue for META."}
{"prompt_id": "FA-E-0188", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the latest ROIC TTM for BRK.B daily."}
{"prompt_id": "FA-E-0189", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that retrieves and logs the Pretax Margin TTM for V daily."}
{"prompt_id": "FA-E-0190", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that plots the annual Income Tax Expense for JPM."}
{"prompt_id": "FA-E-0191", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and store the latest Cash And Cash Equivalents value for WMT."}
{"prompt_id": "FA-E-0192", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the Goodwill value for PG from its latest balance sheet during initialization."}
{"prompt_id": "FA-E-0193", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that logs the Long Term Debt value for UNH daily."}
{"prompt_id": "FA-E-0194", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that plots the Retained Earnings for AAPL from its latest balance sheet update."}
{"prompt_id": "FA-E-0195", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and log the Current Assets for MSFT daily."}
{"prompt_id": "FA-E-0196", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the Current Liabilities for GOOG when fundamental data is available."}
{"prompt_id": "FA-E-0197", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that retrieves and stores the Common Stock Equity value for AMZN daily."}
{"prompt_id": "FA-E-0198", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that plots the Total Liabilities Net Minority Interest for TSLA upon fundamental data update."}
{"prompt_id": "FA-E-0199", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and log the Inventories value for NVDA daily, if applicable."}
{"prompt_id": "FA-E-0200", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the annual Issuance of Capital Stock for JNJ."}
{"prompt_id": "FA-E-0201", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that logs the annual Repurchase of Capital Stock for META."}
{"prompt_id": "FA-E-0202", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that plots the annual Payment of Cash Dividends for BRK.B (if any)."}
{"prompt_id": "FA-E-0203", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and store the TTM Investing Cash Flow for V."}
{"prompt_id": "FA-E-0204", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the TTM Financing Cash Flow for JPM daily."}
{"prompt_id": "FA-E-0205", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that logs the Days Sales Outstanding TTM for WMT daily."}
{"prompt_id": "FA-E-0206", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that plots the Days Inventory Outstanding TTM for PG daily, if applicable."}
{"prompt_id": "FA-E-0207", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect algorithm to fetch and log the Days Payables Outstanding TTM for UNH daily."}
{"prompt_id": "FA-E-0208", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a LEAN Python script to print the Interest Coverage TTM for AAPL daily."}
{"prompt_id": "FA-E-0209", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect algorithm that retrieves and stores the latest Gross Margin TTM for MSFT."}
{"prompt_id": "FA-E-0210", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a LEAN algorithm that plots the Net Income Applicable To Common Shares (Annual) for GOOG."}
{"prompt_id": "FA-E-0211", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the P/E ratio for GOOG daily."}
{"prompt_id": "FA-E-0212", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script to print the Market Cap for AMZN in `Initialize`."}
{"prompt_id": "FA-E-0213", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate QuantConnect LEAN code to plot the TTM Revenue for NVDA daily."}
{"prompt_id": "FA-E-0214", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN script to log the Debt-to-Equity ratio for JNJ daily."}
{"prompt_id": "FA-E-0215", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop QuantConnect LEAN code to store the Dividend Yield for META daily."}
{"prompt_id": "FA-E-0216", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script to log the P/B ratio for V daily."}
{"prompt_id": "FA-E-0217", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to plot the annual Net Income for JPM."}
{"prompt_id": "FA-E-0218", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate QuantConnect LEAN code to print the SectorName for WMT in `Initialize`."}
{"prompt_id": "FA-E-0219", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN script to log the ROE TTM for PG daily."}
{"prompt_id": "FA-E-0220", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN algorithm to plot the QuickRatio for UNH daily."}
{"prompt_id": "FA-E-0221", "strategy_category": "Fundamental Analysis", "prompt_text": "Write QuantConnect LEAN code to log the EPS TTM for AAPL daily."}
{"prompt_id": "FA-E-0222", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the TotalAssets for MSFT in `Initialize`."}
{"prompt_id": "FA-E-0223", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to plot the OperatingMargin TTM for GOOG daily."}
{"prompt_id": "FA-E-0224", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to log the PSRatio for AMZN daily."}
{"prompt_id": "FA-E-0225", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to print the IndustryName for TSLA in `Initialize`."}
{"prompt_id": "FA-E-0226", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to log the TTM FreeCashFlow for NVDA daily."}
{"prompt_id": "FA-E-0227", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to plot the CurrentRatio for JNJ daily."}
{"prompt_id": "FA-E-0228", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to log the BookValuePerShare for META daily."}
{"prompt_id": "FA-E-0229", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the Beta for BRK.B daily."}
{"prompt_id": "FA-E-0230", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the OperatingCashFlow TTM for V in `Initialize`."}
{"prompt_id": "FA-E-0231", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the ROA TTM for JPM daily."}
{"prompt_id": "FA-E-0232", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the annual GrossProfit for WMT."}
{"prompt_id": "FA-E-0233", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the SharesOutstanding for PG daily."}
{"prompt_id": "FA-E-0234", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the CIK for UNH in `Initialize`."}
{"prompt_id": "FA-E-0235", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to plot the PayoutRatio for AAPL daily."}
{"prompt_id": "FA-E-0236", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to log the SalesPerShare TTM for MSFT daily."}
{"prompt_id": "FA-E-0237", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the annual TotalLiabilities for GOOG."}
{"prompt_id": "FA-E-0238", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the PEGRatio for AMZN daily."}
{"prompt_id": "FA-E-0239", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the AssetTurnover TTM for TSLA daily."}
{"prompt_id": "FA-E-0240", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the TTM EBITDA for NVDA."}
{"prompt_id": "FA-E-0241", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the NetMargin TTM for JNJ daily."}
{"prompt_id": "FA-E-0242", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the CountryId for META in `Initialize`."}
{"prompt_id": "FA-E-0243", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to plot the CashReturn for BRK.B daily."}
{"prompt_id": "FA-E-0244", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to log the EarningsYield for V daily."}
{"prompt_id": "FA-E-0245", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the annual ResearchAndDevelopment for JPM."}
{"prompt_id": "FA-E-0246", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the EVEBITDA ratio for WMT daily."}
{"prompt_id": "FA-E-0247", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the InventoryTurnover TTM for PG daily."}
{"prompt_id": "FA-E-0248", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the FCFYield for UNH daily."}
{"prompt_id": "FA-E-0249", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the PCFSRatio for AAPL daily."}
{"prompt_id": "FA-E-0250", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the HeadquarterCity for MSFT in `Initialize`."}
{"prompt_id": "FA-E-0251", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the annual InterestExpense for GOOG."}
{"prompt_id": "FA-E-0252", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the PriceFairValue for AMZN daily."}
{"prompt_id": "FA-E-0253", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the TTM SellingGeneralAndAdministrative expense for TSLA."}
{"prompt_id": "FA-E-0254", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the RevenueGrowth (3yr avg) for NVDA daily."}
{"prompt_id": "FA-E-0255", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the annual CapitalExpenditure for JNJ."}
{"prompt_id": "FA-E-0256", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the PriceChange1M for META daily."}
{"prompt_id": "FA-E-0257", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the annual CostOfRevenue for BRK.B."}
{"prompt_id": "FA-E-0258", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the ROIC TTM for V daily."}
{"prompt_id": "FA-E-0259", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the PretaxMargin TTM for JPM daily."}
{"prompt_id": "FA-E-0260", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the annual IncomeTaxExpense for WMT."}
{"prompt_id": "FA-E-0261", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the CashAndCashEquivalents for PG."}
{"prompt_id": "FA-E-0262", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the Goodwill for UNH in `Initialize`."}
{"prompt_id": "FA-E-0263", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the LongTermDebt for AAPL daily."}
{"prompt_id": "FA-E-0264", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the RetainedEarnings for MSFT."}
{"prompt_id": "FA-E-0265", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the CurrentAssets for GOOG daily."}
{"prompt_id": "FA-E-0266", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the CurrentLiabilities for AMZN."}
{"prompt_id": "FA-E-0267", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to store the CommonStockEquity for TSLA daily."}
{"prompt_id": "FA-E-0268", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the TotalLiabilitiesNetMinorityInterest for NVDA."}
{"prompt_id": "FA-E-0269", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the Inventories value for JNJ daily."}
{"prompt_id": "FA-E-0270", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the annual IssuanceOfCapitalStock for META."}
{"prompt_id": "FA-E-0271", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the annual RepurchaseOfCapitalStock for BRK.B."}
{"prompt_id": "FA-E-0272", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the annual PaymentOfCashDividends for V."}
{"prompt_id": "FA-E-0273", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the TTM InvestingCashFlow for JPM."}
{"prompt_id": "FA-E-0274", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the TTM FinancingCashFlow for WMT daily."}
{"prompt_id": "FA-E-0275", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the DaysSalesOutstanding TTM for PG daily."}
{"prompt_id": "FA-E-0276", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the DaysInventoryOutstanding TTM for UNH daily."}
{"prompt_id": "FA-E-0277", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the DaysPayablesOutstanding TTM for AAPL daily."}
{"prompt_id": "FA-E-0278", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the InterestCoverage TTM for MSFT daily."}
{"prompt_id": "FA-E-0279", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to store the GrossMargin TTM for GOOG."}
{"prompt_id": "FA-E-0280", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the NetIncomeApplicableToCommonShares (Annual) for AMZN."}
{"prompt_id": "FA-E-0281", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the P/E ratio for TSLA daily."}
{"prompt_id": "FA-E-0282", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script to print the Market Cap for JNJ in `Initialize`."}
{"prompt_id": "FA-E-0283", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate QuantConnect LEAN code to plot the TTM Revenue for META daily."}
{"prompt_id": "FA-E-0284", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN script to log the Debt-to-Equity ratio for BRK.B daily."}
{"prompt_id": "FA-E-0285", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop QuantConnect LEAN code to store the Dividend Yield for V daily."}
{"prompt_id": "FA-E-0286", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script to log the P/B ratio for JPM daily."}
{"prompt_id": "FA-E-0287", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to plot the annual Net Income for WMT."}
{"prompt_id": "FA-E-0288", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate QuantConnect LEAN code to print the SectorName for PG in `Initialize`."}
{"prompt_id": "FA-E-0289", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN script to log the ROE TTM for UNH daily."}
{"prompt_id": "FA-E-0290", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN algorithm to plot the QuickRatio for AAPL daily."}
{"prompt_id": "FA-E-0291", "strategy_category": "Fundamental Analysis", "prompt_text": "Write QuantConnect LEAN code to log the EPS TTM for MSFT daily."}
{"prompt_id": "FA-E-0292", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the TotalAssets for GOOG in `Initialize`."}
{"prompt_id": "FA-E-0293", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to plot the OperatingMargin TTM for AMZN daily."}
{"prompt_id": "FA-E-0294", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to log the PSRatio for TSLA daily."}
{"prompt_id": "FA-E-0295", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to print the IndustryName for NVDA in `Initialize`."}
{"prompt_id": "FA-E-0296", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to log the TTM FreeCashFlow for JNJ daily."}
{"prompt_id": "FA-E-0297", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to plot the CurrentRatio for META daily."}
{"prompt_id": "FA-E-0298", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to log the BookValuePerShare for BRK.B daily."}
{"prompt_id": "FA-E-0299", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the Beta for V daily."}
{"prompt_id": "FA-E-0300", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the OperatingCashFlow TTM for JPM in `Initialize`."}
{"prompt_id": "FA-E-0301", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the ROA TTM for WMT daily."}
{"prompt_id": "FA-E-0302", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the annual GrossProfit for PG."}
{"prompt_id": "FA-E-0303", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the SharesOutstanding for UNH daily."}
{"prompt_id": "FA-E-0304", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the CIK for AAPL in `Initialize`."}
{"prompt_id": "FA-E-0305", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to plot the PayoutRatio for MSFT daily."}
{"prompt_id": "FA-E-0306", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to log the SalesPerShare TTM for GOOG daily."}
{"prompt_id": "FA-E-0307", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the annual TotalLiabilities for AMZN."}
{"prompt_id": "FA-E-0308", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the PEGRatio for TSLA daily."}
{"prompt_id": "FA-E-0309", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the AssetTurnover TTM for NVDA daily."}
{"prompt_id": "FA-E-0310", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the TTM EBITDA for JNJ."}
{"prompt_id": "FA-E-0311", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the NetMargin TTM for META daily along with its year-over-year change."}
{"prompt_id": "FA-E-0312", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the CountryId for BRK.B in `Initialize`."}
{"prompt_id": "FA-E-0313", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to plot the CashReturn for V daily."}
{"prompt_id": "FA-E-0314", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to log the EarningsYield for JPM daily."}
{"prompt_id": "FA-E-0315", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the annual ResearchAndDevelopment for WMT."}
{"prompt_id": "FA-E-0316", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the EVEBITDA ratio for PG daily."}
{"prompt_id": "FA-E-0317", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the InventoryTurnover TTM for UNH daily."}
{"prompt_id": "FA-E-0318", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the FCFYield for AAPL daily."}
{"prompt_id": "FA-E-0319", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the PCFSRatio for MSFT daily."}
{"prompt_id": "FA-E-0320", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the HeadquarterCity for GOOG in `Initialize`."}
{"prompt_id": "FA-E-0321", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the annual InterestExpense for AMZN."}
{"prompt_id": "FA-E-0322", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the PriceFairValue for TSLA daily."}
{"prompt_id": "FA-E-0323", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the TTM SellingGeneralAndAdministrative expense for NVDA."}
{"prompt_id": "FA-E-0324", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the RevenueGrowth (3yr avg) for JNJ daily."}
{"prompt_id": "FA-E-0325", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the annual CapitalExpenditure for META."}
{"prompt_id": "FA-E-0326", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the PriceChange1M for BRK.B daily."}
{"prompt_id": "FA-E-0327", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the annual CostOfRevenue for V."}
{"prompt_id": "FA-E-0328", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the ROIC TTM for JPM daily."}
{"prompt_id": "FA-E-0329", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the PretaxMargin TTM for WMT daily."}
{"prompt_id": "FA-E-0330", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the annual IncomeTaxExpense for PG."}
{"prompt_id": "FA-E-0331", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the CashAndCashEquivalents for UNH."}
{"prompt_id": "FA-E-0332", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the Goodwill for AAPL in `Initialize`."}
{"prompt_id": "FA-E-0333", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the LongTermDebt for MSFT daily."}
{"prompt_id": "FA-E-0334", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the RetainedEarnings for GOOG."}
{"prompt_id": "FA-E-0335", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the CurrentAssets for AMZN daily."}
{"prompt_id": "FA-E-0336", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the CurrentLiabilities for TSLA."}
{"prompt_id": "FA-E-0337", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to store the CommonStockEquity for NVDA daily."}
{"prompt_id": "FA-E-0338", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the TotalLiabilitiesNetMinorityInterest for JNJ."}
{"prompt_id": "FA-E-0339", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the Inventories value for META daily."}
{"prompt_id": "FA-E-0340", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the annual IssuanceOfCapitalStock for BRK.B."}
{"prompt_id": "FA-E-0341", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the annual RepurchaseOfCapitalStock for V."}
{"prompt_id": "FA-E-0342", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the annual PaymentOfCashDividends for JPM."}
{"prompt_id": "FA-E-0343", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the TTM InvestingCashFlow for WMT."}
{"prompt_id": "FA-E-0344", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the TTM FinancingCashFlow for PG daily."}
{"prompt_id": "FA-E-0345", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the DaysSalesOutstanding TTM for UNH daily."}
{"prompt_id": "FA-E-0346", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the DaysInventoryOutstanding TTM for AAPL daily."}
{"prompt_id": "FA-E-0347", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the DaysPayablesOutstanding TTM for MSFT daily."}
{"prompt_id": "FA-E-0348", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the InterestCoverage TTM for GOOG daily."}
{"prompt_id": "FA-E-0349", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to store the GrossMargin TTM for AMZN."}
{"prompt_id": "FA-E-0350", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the NetIncomeApplicableToCommonShares (Annual) for TSLA."}
{"prompt_id": "FA-E-0351", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the NetMargin TTM for NVDA daily and compare to industry average."}
{"prompt_id": "FA-E-0352", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script to print the Market Cap for TSLA in `Initialize`."}
{"prompt_id": "FA-E-0353", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate QuantConnect LEAN code to plot the TTM Revenue for JNJ daily."}
{"prompt_id": "FA-E-0354", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN script to log the Debt-to-Equity ratio for META daily."}
{"prompt_id": "FA-E-0355", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop QuantConnect LEAN code to store the Dividend Yield for BRK.B daily (if applicable)."}
{"prompt_id": "FA-E-0356", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script to log the P/B ratio for WMT daily."}
{"prompt_id": "FA-E-0357", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to plot the annual Net Income for PG."}
{"prompt_id": "FA-E-0358", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate QuantConnect LEAN code to print the SectorName for UNH in `Initialize`."}
{"prompt_id": "FA-E-0359", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN script to log the ROE TTM for AAPL daily."}
{"prompt_id": "FA-E-0360", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN algorithm to plot the QuickRatio for MSFT daily."}
{"prompt_id": "FA-E-0361", "strategy_category": "Fundamental Analysis", "prompt_text": "Write QuantConnect LEAN code to log the EPS TTM for GOOG daily."}
{"prompt_id": "FA-E-0362", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the TotalAssets for AMZN in `Initialize`."}
{"prompt_id": "FA-E-0363", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to plot the OperatingMargin TTM for TSLA daily."}
{"prompt_id": "FA-E-0364", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to log the PSRatio for NVDA daily."}
{"prompt_id": "FA-E-0365", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to print the IndustryName for JNJ in `Initialize`."}
{"prompt_id": "FA-E-0366", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to log the TTM FreeCashFlow for META daily."}
{"prompt_id": "FA-E-0367", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to plot the CurrentRatio for BRK.B daily."}
{"prompt_id": "FA-E-0368", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to log the BookValuePerShare for V daily."}
{"prompt_id": "FA-E-0369", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the Beta for JPM daily."}
{"prompt_id": "FA-E-0370", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the OperatingCashFlow TTM for WMT in `Initialize`."}
{"prompt_id": "FA-E-0371", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the ROA TTM for PG daily."}
{"prompt_id": "FA-E-0372", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the annual GrossProfit for UNH."}
{"prompt_id": "FA-E-0373", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the SharesOutstanding for AAPL daily."}
{"prompt_id": "FA-E-0374", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the CIK for MSFT in `Initialize`."}
{"prompt_id": "FA-E-0375", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to plot the PayoutRatio for GOOG daily."}
{"prompt_id": "FA-E-0376", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to log the SalesPerShare TTM for AMZN daily."}
{"prompt_id": "FA-E-0377", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the annual TotalLiabilities for TSLA."}
{"prompt_id": "FA-E-0378", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the PEGRatio for NVDA daily."}
{"prompt_id": "FA-E-0379", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the AssetTurnover TTM for JNJ daily."}
{"prompt_id": "FA-E-0380", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the TTM EBITDA for META."}
{"prompt_id": "FA-E-0381", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the NetMargin TTM for BRK.B daily."}
{"prompt_id": "FA-E-0382", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the CountryId for V in `Initialize`."}
{"prompt_id": "FA-E-0383", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to plot the CashReturn for JPM daily."}
{"prompt_id": "FA-E-0384", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to log the EarningsYield for WMT daily."}
{"prompt_id": "FA-E-0385", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the annual ResearchAndDevelopment for PG."}
{"prompt_id": "FA-E-0386", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the EVEBITDA ratio for UNH daily."}
{"prompt_id": "FA-E-0387", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the InventoryTurnover TTM for AAPL daily."}
{"prompt_id": "FA-E-0388", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the FCFYield for MSFT daily."}
{"prompt_id": "FA-E-0389", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the PCFSRatio for GOOG daily."}
{"prompt_id": "FA-E-0390", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the HeadquarterCity for AMZN in `Initialize`."}
{"prompt_id": "FA-E-0391", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the annual InterestExpense for TSLA."}
{"prompt_id": "FA-E-0392", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the PriceFairValue for NVDA daily and highlight when undervalued."}
{"prompt_id": "FA-E-0393", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the TTM SellingGeneralAndAdministrative expense for JNJ."}
{"prompt_id": "FA-E-0394", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the RevenueGrowth (3yr avg) for META daily."}
{"prompt_id": "FA-E-0395", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the annual CapitalExpenditure for BRK.B."}
{"prompt_id": "FA-E-0396", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the PriceChange1M for V daily."}
{"prompt_id": "FA-E-0397", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the annual CostOfRevenue for JPM."}
{"prompt_id": "FA-E-0398", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the ROIC TTM for WMT daily."}
{"prompt_id": "FA-E-0399", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the PretaxMargin TTM for PG daily."}
{"prompt_id": "FA-E-0400", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the annual IncomeTaxExpense for UNH."}
{"prompt_id": "FA-E-0401", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the CashAndCashEquivalents for AAPL."}
{"prompt_id": "FA-E-0402", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the Goodwill for MSFT in `Initialize`."}
{"prompt_id": "FA-E-0403", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the LongTermDebt for GOOG daily."}
{"prompt_id": "FA-E-0404", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the RetainedEarnings for AMZN."}
{"prompt_id": "FA-E-0405", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the CurrentAssets for TSLA daily."}
{"prompt_id": "FA-E-0406", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the CurrentLiabilities for NVDA."}
{"prompt_id": "FA-E-0407", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to store the CommonStockEquity for JNJ daily."}
{"prompt_id": "FA-E-0408", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the TotalLiabilitiesNetMinorityInterest for META."}
{"prompt_id": "FA-E-0409", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the Inventories value for BRK.B daily."}
{"prompt_id": "FA-E-0410", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the annual IssuanceOfCapitalStock for V."}
{"prompt_id": "FA-E-0411", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the annual RepurchaseOfCapitalStock for JPM."}
{"prompt_id": "FA-E-0412", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the annual PaymentOfCashDividends for WMT."}
{"prompt_id": "FA-E-0413", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store the TTM InvestingCashFlow for PG."}
{"prompt_id": "FA-E-0414", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the TTM FinancingCashFlow for UNH daily."}
{"prompt_id": "FA-E-0415", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log the DaysSalesOutstanding TTM for AAPL daily."}
{"prompt_id": "FA-E-0416", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the DaysInventoryOutstanding TTM for MSFT daily."}
{"prompt_id": "FA-E-0417", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log the DaysPayablesOutstanding TTM for GOOG daily."}
{"prompt_id": "FA-E-0418", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print the InterestCoverage TTM for AMZN daily."}
{"prompt_id": "FA-E-0419", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to store the GrossMargin TTM for TSLA."}
{"prompt_id": "FA-E-0420", "strategy_category": "Fundamental Analysis", "prompt_text": "Create QuantConnect LEAN code to plot the NetIncomeApplicableToCommonShares (Annual) for NVDA."}
{"prompt_id": "FA-E-0421", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log Meta's (META) Interest Coverage TTM daily and track its quarterly trend."}
{"prompt_id": "FA-E-0422", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print Berkshire Hathaway's (BRK.B) Book Value Per Share in `Initialize`."}
{"prompt_id": "FA-E-0423", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to store JPMorgan's (JPM) Current Ratio daily."}
{"prompt_id": "FA-E-0424", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log Amazon's (AMZN) Debt-to-Equity ratio every day."}
{"prompt_id": "FA-E-0425", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log Tesla's (TSLA) Price-to-Sales (P/S) ratio daily."}
{"prompt_id": "FA-E-0426", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script that logs NVIDIA's (NVDA) Return on Equity (ROE) daily."}
{"prompt_id": "FA-E-0427", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to print J&J's (JNJ) Sector Name in `Initialize`."}
{"prompt_id": "FA-E-0428", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to plot NVIDIA's (NVDA) Free Cash Flow Yield (FCFYield) daily."}
{"prompt_id": "FA-E-0429", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate QuantConnect LEAN code to log Berkshire Hathaway's (BRK.B) Price-to-Book (P/B) ratio daily."}
{"prompt_id": "FA-E-0430", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN algorithm to print Visa's (V) EPS TTM during initialization."}
{"prompt_id": "FA-E-0431", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN script to plot JPMorgan's (JPM) Operating Margin TTM."}
{"prompt_id": "FA-E-0432", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log Walmart's (WMT) Price-to-Sales (P/S) ratio daily."}
{"prompt_id": "FA-E-0433", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script to print P&G's (PG) Industry Name in `Initialize`."}
{"prompt_id": "FA-E-0434", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to log Meta's (META) PEG Ratio daily if positive."}
{"prompt_id": "FA-E-0435", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to plot Apple's (AAPL) Quick Ratio daily."}
{"prompt_id": "FA-E-0436", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN script to log Microsoft's (MSFT) Book Value Per Share daily."}
{"prompt_id": "FA-E-0437", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store Google's (GOOG) Current Assets value daily."}
{"prompt_id": "FA-E-0438", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN algorithm to plot Amazon's (AMZN) TTM Operating Cash Flow."}
{"prompt_id": "FA-E-0439", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN script to log Tesla's (TSLA) Return on Assets (ROA) TTM daily."}
{"prompt_id": "FA-E-0440", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store Apple's (AAPL) Return on Invested Capital (ROIC) TTM daily."}
{"prompt_id": "FA-E-0441", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate QuantConnect LEAN code to plot J&J's (JNJ) Payout Ratio daily."}
{"prompt_id": "FA-E-0442", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script to print Visa's (V) Price Fair Value (Morningstar) daily."}
{"prompt_id": "FA-E-0443", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to print Berkshire Hathaway's (BRK.B) PEG Ratio daily if positive."}
{"prompt_id": "FA-E-0444", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop QuantConnect LEAN code to plot Visa's (V) Asset Turnover TTM daily."}
{"prompt_id": "FA-E-0445", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to log JPMorgan's (JPM) TTM EBITDA daily."}
{"prompt_id": "FA-E-0446", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN algorithm to print Walmart's (WMT) Net Margin TTM daily."}
{"prompt_id": "FA-E-0447", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log Walmart's (WMT) Earnings Per Share (EPS) TTM daily."}
{"prompt_id": "FA-E-0448", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log UnitedHealth's (UNH) Earnings Yield daily."}
{"prompt_id": "FA-E-0449", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to plot Google's (GOOG) Return on Assets (ROA) TTM daily."}
{"prompt_id": "FA-E-0450", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script to plot Microsoft's (MSFT) Inventory Turnover TTM."}
{"prompt_id": "FA-E-0451", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log Google's (GOOG) Free Cash Flow Yield (FCFYield) daily."}
{"prompt_id": "FA-E-0452", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop QuantConnect LEAN code to print Amazon's (AMZN) Price/Cash Flow Per Share Ratio (PCFSRatio) daily."}
{"prompt_id": "FA-E-0453", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to plot Tesla's (TSLA) Price Fair Value (Morningstar) daily."}
{"prompt_id": "FA-E-0454", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN algorithm to log NVIDIA's (NVDA) Revenue Growth (3yr avg) daily."}
{"prompt_id": "FA-E-0455", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store NVIDIA's (NVDA) Price-to-Earnings (P/E) ratio daily."}
{"prompt_id": "FA-E-0456", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to plot Meta's (META) Return on Invested Capital (ROIC) TTM."}
{"prompt_id": "FA-E-0457", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to log Meta's (META) Days Inventory Outstanding TTM daily."}
{"prompt_id": "FA-E-0458", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script to print Visa's (V) Long Term Debt value during initialization."}
{"prompt_id": "FA-E-0459", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to plot JPMorgan's (JPM) Retained Earnings upon fundamental update."}
{"prompt_id": "FA-E-0460", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop QuantConnect LEAN code to log Walmart's (WMT) Current Assets daily."}
{"prompt_id": "FA-E-0461", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print P&G's (PG) Current Liabilities daily."}
{"prompt_id": "FA-E-0462", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN algorithm to plot UnitedHealth's (UNH) Common Stock Equity daily."}
{"prompt_id": "FA-E-0463", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log Tesla's (TSLA) Gross Margin TTM daily."}
{"prompt_id": "FA-E-0464", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to print Microsoft's (MSFT) Inventories value in `Initialize` (if applicable)."}
{"prompt_id": "FA-E-0465", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script to print NVIDIA's (NVDA) Days Payables Outstanding TTM daily."}
{"prompt_id": "FA-E-0466", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script to log Amazon's (AMZN) TTM Financing Cash Flow daily."}
{"prompt_id": "FA-E-0467", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to print Tesla's (TSLA) Days Sales Outstanding TTM daily."}
{"prompt_id": "FA-E-0468", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop QuantConnect LEAN code to plot NVIDIA's (NVDA) Days Inventory Outstanding TTM."}
{"prompt_id": "FA-E-0469", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to log J&J's (JNJ) Days Payables Outstanding TTM daily."}
{"prompt_id": "FA-E-0470", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN algorithm to print Meta's (META) Interest Coverage TTM and compare it against competitors."}
{"prompt_id": "FA-E-0471", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to log Visa's (V) Retained Earnings daily."}
{"prompt_id": "FA-E-0472", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log Visa's (V) Net Income Applicable To Common Shares (Annual)."}
{"prompt_id": "FA-E-0473", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to store Walmart's (WMT) Price-to-Book (P/B) ratio daily and calculate its 50-day moving average."}
{"prompt_id": "FA-E-0474", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script to plot Walmart's (WMT) P/B ratio against retail industry median values daily."}
{"prompt_id": "FA-E-0475", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log P&G's (PG) annual Net Income."}
{"prompt_id": "FA-E-0476", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop QuantConnect LEAN code to print UnitedHealth's (UNH) Sector Name in `Initialize`."}
{"prompt_id": "FA-E-0477", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to plot Apple's (AAPL) ROE TTM daily."}
{"prompt_id": "FA-E-0478", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN algorithm to log Microsoft's (MSFT) Quick Ratio daily."}
{"prompt_id": "FA-E-0479", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log Microsoft's (MSFT) Earnings Yield daily."}
{"prompt_id": "FA-E-0480", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to plot Amazon's (AMZN) Total Assets upon fundamental update."}
{"prompt_id": "FA-E-0481", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script to print Amazon's (AMZN) Net Margin TTM daily."}
{"prompt_id": "FA-E-0482", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script to print NVIDIA's (NVDA) P/S ratio daily."}
{"prompt_id": "FA-E-0483", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to plot J&J's (JNJ) Industry Name (Note: Plotting text isn't standard; interpret as log/print). Log J&J's Industry Name."}
{"prompt_id": "FA-E-0484", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop QuantConnect LEAN code to log Meta's (META) TTM Free Cash Flow daily."}
{"prompt_id": "FA-E-0485", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to plot Berkshire Hathaway's (BRK.B) Current Ratio daily."}
{"prompt_id": "FA-E-0486", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN algorithm to print Visa's (V) Book Value Per Share daily."}
{"prompt_id": "FA-E-0487", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to log Berkshire Hathaway's (BRK.B) Asset Turnover TTM daily."}
{"prompt_id": "FA-E-0488", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to plot Walmart's (WMT) TTM Operating Cash Flow."}
{"prompt_id": "FA-E-0489", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to log Tesla's (TSLA) Free Cash Flow Yield (FCFYield) daily and compare to automotive sector average."}
{"prompt_id": "FA-E-0490", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script to print UnitedHealth's (UNH) Shares Outstanding daily."}
{"prompt_id": "FA-E-0491", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to plot Apple's (AAPL) Payout Ratio daily."}
{"prompt_id": "FA-E-0492", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop QuantConnect LEAN code to log Microsoft's (MSFT) Sales Per Share TTM daily."}
{"prompt_id": "FA-E-0493", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to print Google's (GOOG) PEG Ratio daily."}
{"prompt_id": "FA-E-0494", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN algorithm to plot Amazon's (AMZN) Asset Turnover TTM daily."}
{"prompt_id": "FA-E-0495", "strategy_category": "Fundamental Analysis", "prompt_text": "Generate a QuantConnect LEAN script to log Tesla's (TSLA) Free Cash Flow Yield (FCFYield) history and create a quarterly trend chart."}
{"prompt_id": "FA-E-0496", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to print NVIDIA's (NVDA) Net Margin TTM daily along with its year-over-year change."}
{"prompt_id": "FA-E-0497", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop a QuantConnect LEAN algorithm to log NVIDIA's (NVDA) Price Fair Value (Morningstar) daily and create buy/sell signals when crossing thresholds."}
{"prompt_id": "FA-E-0498", "strategy_category": "Fundamental Analysis", "prompt_text": "Create a QuantConnect LEAN script to log Meta's (META) Earnings Yield daily."}
{"prompt_id": "FA-E-0499", "strategy_category": "Fundamental Analysis", "prompt_text": "Write a QuantConnect LEAN algorithm to print Berkshire Hathaway's (BRK.B) EV/EBITDA ratio daily."}
{"prompt_id": "FA-E-0500", "strategy_category": "Fundamental Analysis", "prompt_text": "Develop QuantConnect LEAN code to plot Visa's (V) Inventory Turnover TTM daily."}